#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp","languageName":"csharp"},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

# Playground - Agent POC med Ollama

Dette er vores POC/eksperimenterings-sandbox til at validere Ollama-integration, inden vi modificerer workshoppen.

**Form√•l:**
1. Verificer at Ollama k√∏rer
2. Test tool calling med OllamaSharp
3. Implementer minimal agent (~200 linjer)
4. Skab `HelloAgentWorld.cs` som bevis p√• at det virker

---

## 1. Ollama Setup & Verification

#!markdown

### 1.1 Er Ollama installeret?

Installer Ollama:

**Windows (PowerShell):**
```powershell
winget install Ollama.Ollama
```

**Mac (Homebrew):**
```bash
brew install ollama
```

**Linux:**
```bash
curl -fsSL https://ollama.com/install.sh | sh
```

Start Ollama og pull modellen:
```bash
ollama serve
ollama pull llama3.1:8b
```
üëÜüèª Kan ogs√• udf√∏res i Ollama GUI
```powershell
V√¶lg en model, skriv en prompt, f.eks. "hej" og tryk retur. Modellen skulle nu downloades.
```

#!csharp

// Test: Kan vi n√• Ollama?
using System.Net.Http;

var httpClient = new HttpClient();

string selectedModelName = "llama3.1:8b";

try
{
    await httpClient.GetStringAsync("http://localhost:11434/api/tags");
    Console.WriteLine($"‚úÖ Ollama k√∏rer! Model: {selectedModelName}");
}
catch
{
    Console.WriteLine("‚ùå Ollama k√∏rer IKKE. Start med: ollama serve");
}

#!markdown

### 1.2 OllamaSharp NuGet Package

#!csharp

#r "nuget: OllamaSharp, 5.1.3"

using OllamaSharp;
using OllamaSharp.Models;
using OllamaSharp.Models.Chat;

Console.WriteLine("OllamaSharp loaded!");

#!markdown

### 1.3 Simpel Chat Test (uden tools)

#!csharp

var ollama = new OllamaApiClient("http://localhost:11434");
ollama.SelectedModel = selectedModelName ?? "llama3.1:8b";

var chat = new Chat(ollama);

Console.WriteLine("Sender test besked...\n");

await foreach (var token in chat.SendAsync("Sig 'Hello agentic world!' p√• dansk."))
{
    Console.Write(token);
}

Console.WriteLine("\n\nChat virker!");

#!markdown

---

## 2. Tool Definition & Testing

#!markdown

### 2.1 Manual Tool Definition

Vi definerer et `create_file` tool, som giver LLM'en mulighed for at oprette filer p√• filsystemet:

#!csharp

using System.Text.Json;
using System.Text.Json.Nodes;

// Tool definition for create_file
var createFileTool = new OllamaSharp.Models.Chat.Tool
{
    Function = new Function
    {
        Name = "create_file",
        Description = "Create a file with the given content. Use this when the user asks you to create, write, or generate a file.",
        Parameters = new Parameters
        {
            Properties = new Dictionary<string, Property>
            {
                ["path"] = new Property
                {
                    Type = "string",
                    Description = "The file path to create (e.g., 'HelloWorld.cs')"
                },
                ["content"] = new Property
                {
                    Type = "string",
                    Description = "The content to write to the file"
                }
            },
            Required = new[] { "path", "content" }
        }
    }
};

Console.WriteLine("Tool defineret:");
Console.WriteLine($"  Name: {createFileTool.Function.Name}");
Console.WriteLine($"  Description: {createFileTool.Function.Description}");

#!markdown

### 2.2 Tool Execution Function

#!csharp

using System.IO;

string ExecuteCreateFile(string path, string content)
{
    var fullPath = Path.Combine(Environment.CurrentDirectory, path);

    try
    {
        File.WriteAllText(fullPath, content);
        return $"File created successfully at: {fullPath}";
    }
    catch (Exception e)
    {
        return $"Error creating file: {e.Message}";
    }
}

// Test uden LLM
var testResult = ExecuteCreateFile("test-file.txt", "Hello from test!");
Console.WriteLine(testResult);

// Cleanup
File.Delete(Path.Combine(Environment.CurrentDirectory, "test-file.txt"));
Console.WriteLine("Test file cleaned up.");

#!markdown

---

## 3. The Agentic Loop (~200 lines demystified)

#!markdown

### 3.1 The Core Insight

Fra Mihail Eric's artikel "The Emperor Has No Clothes":

> **The LLM never actually touches your filesystem. It just *asks* for things to happen.**

Hele loopet er:
1. User sender besked
2. LLM beslutter hvad der skal ske
3. Hvis LLM vil bruge et tool ‚Üí vi udf√∏rer det lokalt
4. Resultat sendes tilbage til LLM
5. Gentag indtil LLM er f√¶rdig

#!csharp

// The demystified agentic loop
async Task<string> RunAgent(string userMessage, List<Tool> tools)
{
    var client = new OllamaApiClient("http://localhost:11434");
    client.SelectedModel = selectedModelName ?? "llama3.1:8b";

    var messages = new List<Message>
    {
        new Message
        {
            Role = ChatRole.System,
            Content = """
                You are a helpful coding assistant. When asked to create files,
                use the create_file tool. Always respond in the same language as
                the user's message.
                """
        },
        new Message { Role = ChatRole.User, Content = userMessage }
    };

    var maxIterations = 10;
    var iteration = 0;

    while (iteration < maxIterations)
    {
        iteration++;
        Console.WriteLine($"\n--- Iteration {iteration} ---");

        // Send to LLM
        var request = new ChatRequest
        {
            Model = selectedModelName ?? "llama3.1:8b",
            Messages = messages,
            Tools = tools,
            Stream = false
        };

        ChatResponseStream? response = null;
        await foreach (var chunk in client.ChatAsync(request))
        {
            response = chunk;
        }
        var assistantMessage = response?.Message;
        messages.Add(assistantMessage);

        // Check for tool calls
        if (assistantMessage.ToolCalls != null && assistantMessage.ToolCalls.Any())
        {
            Console.WriteLine($"LLM wants to call {assistantMessage.ToolCalls.Count()} tool(s)");

            foreach (var toolCall in assistantMessage.ToolCalls)
            {
                Console.WriteLine($"  Tool: {toolCall.Function.Name}");
                Console.WriteLine($"  Args: {JsonSerializer.Serialize(toolCall.Function.Arguments)}");

                // Execute the tool
                string toolResult;
                if (toolCall.Function.Name == "create_file")
                {
                    var args = toolCall.Function.Arguments;
                    var path = args["path"]?.ToString() ?? "unknown.txt";
                    var content = args["content"]?.ToString() ?? "";
                    toolResult = ExecuteCreateFile(path, content);
                }
                else
                {
                    toolResult = $"Unknown tool: {toolCall.Function.Name}";
                }

                Console.WriteLine($"  Result: {toolResult}");

                // Add tool result to messages
                messages.Add(new Message
                {
                    Role = ChatRole.Tool,
                    Content = toolResult
                });
            }
        }
        else
        {
            // No tool calls - LLM is done
            Console.WriteLine("LLM finished (no tool calls)");
            return assistantMessage.Content ?? "No response";
        }
    }

    return "Max iterations reached";
}

Console.WriteLine("Agentic loop function defined!");

#!markdown

### 3.2 Test: Create HelloAgentWorld.cs

#!csharp

var tools = new List<Tool> { createFileTool };

var result = await RunAgent(
    "Lav en C# fil der hedder 'HelloAgentWorld.cs' og printer 'Hello Agent World!' til konsollen.",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result);

#!markdown

### 3.3 Verify the file was created

#!csharp

var filePath = Path.Combine(Environment.CurrentDirectory, "HelloAgentWorld.cs");

if (File.Exists(filePath))
{
    Console.WriteLine("SUCCESS! File created:");
    Console.WriteLine(new string('-', 40));
    Console.WriteLine(File.ReadAllText(filePath));
    Console.WriteLine(new string('-', 40));
}
else
{
    Console.WriteLine("File was NOT created. Check the agent output above.");
}

#!markdown

---

## 4. MCP Servers

#!markdown

### 4.0 ChargeSmart Data (til MCP)

F√∏rst definerer vi ChargeSmart netv√¶rkets data, som vores MCP server skal bruge.

#!csharp

// ChargeSmart station data
record StationInfo(string Id, string Name, string Location, int PowerKw, string Type);

var stations = new Dictionary<string, StationInfo>
{
    ["CPH-001"] = new("CPH-001", "N√∏rreport Station", "N√∏rreport", 150, "ultra-fast"),
    ["CPH-002"] = new("CPH-002", "Fisketorvet Parking", "Fisketorvet", 50, "fast"),
    ["CPH-003"] = new("CPH-003", "Tivoli Garage", "Tivoli", 50, "fast"),
    ["CPH-004"] = new("CPH-004", "√òrestad Center", "√òrestad", 150, "ultra-fast"),
    ["CPH-005"] = new("CPH-005", "Amager Strandpark", "Amager", 22, "slow"),
};

var activeSessions = new Dictionary<string, (string vehicleId, DateTime start, double kwh)>
{
    ["CPH-002"] = ("Tesla-Model-3", DateTime.Now.AddMinutes(-45), 28.5),
};

decimal GetTariff(int hour) => hour switch
{
    >= 0 and < 6 => 1.50m,
    >= 6 and < 17 => 2.50m,
    >= 17 and < 21 => 4.00m,
    _ => 2.50m
};

Console.WriteLine($"‚úÖ ChargeSmart data: {stations.Count} stationer, {activeSessions.Count} aktive sessioner");

#!markdown

### 4.1 Hvad er MCP?

**Model Context Protocol (MCP)** er en √•ben standard fra Anthropic der standardiserer
hvordan AI-agenter kommunikerer med eksterne tools.

I stedet for at definere tools inline (som i Section 2), kan tools:
- Leve i separate processer (MCP servere)
- Opdages dynamisk af agenten
- Deles p√• tv√¶rs af forskellige agenter

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     JSON-RPC/stdio     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Agent     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ MCP Server  ‚îÇ
‚îÇ  (notebook) ‚îÇ                        ‚îÇ (tools)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#!markdown

### 4.2 Inline MCP Server

I stedet for at starte en ekstern server-proces, opretter vi en **inline MCP server** der bruger in-memory pipes.

#!csharp

// MCP packages
#r "nuget: ModelContextProtocol, 0.5.0-preview.1"
#r "nuget: Microsoft.Extensions.AI, 9.1.0-preview.1.25064.3"

using System.IO.Pipelines;
using Microsoft.Extensions.AI;
using ModelContextProtocol.Client;
using ModelContextProtocol.Server;

Console.WriteLine("MCP packages loaded!");

#!markdown

### 4.3 Opret Inline MCP Server

#!csharp

// Opret in-memory pipes til kommunikation
Pipe clientToServer = new(), serverToClient = new();

// Start MCP server med ChargeSmart tools
var mcpServer = McpServerFactory.Create(
    new StreamServerTransport(
        clientToServer.Reader.AsStream(),
        serverToClient.Writer.AsStream()),
    new McpServerOptions
    {
        ServerInfo = new() { Name = "ChargeSmart", Version = "1.0" },
        Capabilities = new() { Tools = new() { } }
    },
    builder => builder
        .WithTools([
            McpServerTool.Create(
                (string stationId) =>
                {
                    if (!stations.TryGetValue(stationId, out var station))
                        return $"Error: Station {stationId} not found";
                    var hasSession = activeSessions.TryGetValue(stationId, out var session);
                    return hasSession
                        ? $"Station {stationId} ({station.Name}): IN USE"
                        : $"Station {stationId} ({station.Name}): AVAILABLE - {station.PowerKw}kW {station.Type}";
                },
                new() { Name = "get_station_status", Description = "Get status of a charging station by ID (e.g. CPH-001)" }),

            McpServerTool.Create(
                () => string.Join("\n", stations.Values.Select(s =>
                    $"- {s.Id}: {s.Name} - {(activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE")}")),
                new() { Name = "list_stations", Description = "List all charging stations" }),

            McpServerTool.Create(
                (double kwh, int hour) => $"Charging {kwh:F1} kWh at {hour:00}:00 = {(decimal)kwh * GetTariff(hour):F2} DKK",
                new() { Name = "calculate_cost", Description = "Calculate charging cost for kWh at given hour (0-23)" })
        ])
);

_ = mcpServer.RunAsync();
Console.WriteLine("‚úÖ MCP Server startet!");

#!markdown

### 4.4 Opret MCP Client

#!csharp

// Forbind client til samme pipes (omvendt retning)
var mcpClient = await McpClient.CreateAsync(
    new StreamClientTransport(
        serverToClient.Reader.AsStream(),
        clientToServer.Writer.AsStream()));

var mcpTools = await mcpClient.ListToolsAsync();

Console.WriteLine($"üîå Fundet {mcpTools.Count} tools fra MCP server:");
foreach (var tool in mcpTools)
{
    Console.WriteLine($"  - {tool.Name}: {tool.Description}");
}

#!markdown

### 4.5 Brug MCP Tools med IChatClient

OllamaApiClient implementerer `IChatClient`, s√• vi kan bruge den direkte med MCP tools!
`UseFunctionInvocation()` h√•ndterer automatisk tool-kald og -resultater.

#!csharp

// OllamaApiClient IS an IChatClient - wrap it with function invocation
IChatClient chatClient = new ChatClientBuilder(ollama)
    .UseFunctionInvocation()
    .Build();

Console.WriteLine("Sender besked med MCP tools...\n");

var messages = new List<ChatMessage>
{
    new(ChatRole.User, "Hvilke ladestationer er ledige? Hvad koster 20 kWh kl. 19?")
};

// GetStreamingResponseAsync med MCP tools - tool calls h√•ndteres automatisk!
await foreach (var update in chatClient.GetStreamingResponseAsync(
    messages,
    new() { Tools = [.. mcpTools] }))
{
    Console.Write(update.Text);
}

Console.WriteLine("\n\n‚úÖ Done!")

#!markdown

---

## 5. Experimentation Zone

Brug denne sektion til at eksperimentere med:
- Forskellige prompts
- Flere MCP tools
- Egne MCP servere

#!csharp

// Din eksperimentering her...

#!markdown

---

## 6. GitHub Copilot Skills (VS Code Integration)

Vi har nu set hvordan vi kan bygge en agent med tools (sektion 2-3) og MCP (sektion 4).
Men hvad hvis vi allerede har en agent? **GitHub Copilot!**

VS Code 1.108 introducerede eksperimentel support for "agent skills" -
mapper med SKILL.md filer som Copilot automatisk indl√¶ser n√•r de er relevante.

### 6.1 Hvad er en Copilot Skill?

En skill er en mappe med struktureret viden:

```
.github/skills/
‚îî‚îÄ‚îÄ file-creator/
    ‚îî‚îÄ‚îÄ SKILL.md
```

N√•r du sp√∏rger Copilot om noget, tjekker den om en skill matcher - og indl√¶ser den automatisk.

#!markdown

### 6.2 √òvelse: Opret din f√∏rste Copilot Skill

**M√•l:** F√• GitHub Copilot til at g√∏re det samme som vores tool + MCP + agent - oprette filer!

> **Vigtig note:** VS Code Skills er eksperimentelt (v1.108+). Hvis det ikke virker, tjek:
> - Er du p√• VS Code 1.108 eller nyere? (`Help > About`)
> - Er Copilot-udvidelsen opdateret?
> - Er `chat.useAgentSkills` aktiveret i settings? (s√∏g efter "useAgentSkills")

#### Step 1: Opret skill mappe

K√∏r i terminal:

**PowerShell (Windows):**
```powershell
New-Item -ItemType Directory -Force -Path ".github/skills/file-creator"
```

**Bash (Mac/Linux):**
```bash
mkdir -p .github/skills/file-creator
```

#### Step 2: Opret SKILL.md

Opret filen `.github/skills/file-creator/SKILL.md` med dette indhold:

```yaml
---
name: file-creator
description: Creates files when the user asks to create, write, or generate a file
---

# File Creator Skill

Du er en hj√¶lpsom assistent der opretter filer n√•r brugeren beder om det.

## Instruktioner

N√•r brugeren beder dig om at oprette en fil:

1. **Parse anmodningen** - Find filnavn og indhold
2. **Opret filen** - Brug VS Code's fil-oprettelse
3. **Bekr√¶ft** - Fort√¶l brugeren at filen er oprettet

## Eksempler

**Bruger:** "Lav en fil der hedder HelloCopilot.cs med Hello World"
**Handling:** Opret HelloCopilot.cs med C# Hello World kode

**Bruger:** "Opret en README.md til mit projekt"
**Handling:** Opret README.md med passende indhold
```

#!markdown

#### Step 3: Test med GitHub Copilot Chat

1. √Öbn **Copilot Chat** (Ctrl+Alt+I eller via sidebar)
2. Pr√∏v disse prompts:
   - "Opret en fil HelloCopilot.cs der printer 'Hello fra Copilot Skill!'"
   - "Lav en simpel C# fil kaldet Test.cs"

#### Step 4: Verificer

Tjek om filen blev oprettet i roden af projektet.

#!markdown

### 6.3 Sammenligning: Tool vs MCP vs Skill

| Aspekt | Tool (sektion 2) | MCP (sektion 4) | Copilot Skill |
|--------|------------------|-----------------|---------------|
| Definition | Inline i kode | Ekstern server | SKILL.md fil |
| Runtime | Din agent | MCP server proces | VS Code + Copilot |
| Discovery | Hardcoded | Dynamisk via MCP | Automatisk |
| Kr√¶ver | OllamaSharp + kode | MCP SDK + server | Kun SKILL.md |

**Konklusion:** Skills er den enkleste vej til at udvide en eksisterende agent (Copilot) med dom√¶neviden!

#!markdown

### 6.4 G√• videre

Pr√∏v at udvide din skill med:
- Flere filtyper (.cs, .md, .json, .yaml)
- Specifikke templates (fx "Opret en xUnit test fil")
- Dom√¶ne-specifik viden (fx "Opret en MCP server fil")
