#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

# Agents, MCP & Skills

En praktisk workshop hvor vi udforsker den nye verden af **agentic software engineering**.

---

## Agenda (ca. 3,5 timer)

| Tid | Emne | √òvelser |
|-----|------|---------|
| 20 min | Intro, Recap & Polyglot Notebooks | |
| 70 min | Agenter - teori og byg din egen | **√òvelse 1:** Tool Execute-funktioner, **√òvelse 2:** Human-in-the-loop |
| 15 min | Abstraktionsstigen ‚Äì OllamaSharp.Tool | *Valgfri* |
| 15 min | *Pause* | |
| 45 min | Abstraktionsstigen ‚Äì MCP | **√òvelse 3:** AIFunction Tools |
| 20 min | Extension: get_nearest_station | **√òvelse 4:** Nyt tool |
| 25 min | Skills ‚Äì teori og pr√∏v med GitHub Copilot | SKILL.md |
| 10 min | Afrunding | |

---

#!markdown

# Del 0: Intro, Recap & Polyglot Notebooks
*20 minutter*

#!markdown

#### ‚ÑπÔ∏è Install√©r Ollama nu, da det tager lidt tid

**Windows (PowerShell):**
```powershell
winget install Ollama.Ollama
```

**Mac (Homebrew):**
```bash
brew install ollama
```

Start Ollama og hiv modellen ned:
```bash
ollama serve
ollama pull llama3.1:8b
```

üëÜüèª kan ogs√• foretages i GUI; v√¶lg model, skriv en prompt (f.eks. "hej") og tryk retur

## Opsummering fra sidste gang

- LLMs & Agents - What are they, and why can they code? ‚Äî Martin
- Agentisk softwareudvikling for personlig produktivitet ‚Äî Emil
- Agentisk Software Engineering for fuld SDLC af et produkt ‚Äî Magnus

Lige denne planche er meget relevant mht. dagens seance: [How LLMs Learn: The Three Stages](https://martinrl.github.io/presentations/what-are-llms-and-agents/index.html#14)

<img src="images/LLMs-14.png" alt="LLMs-14" width="600" style="max-width: 100%;">

---

#!markdown

## Intro til Polyglot Notebooks

### Hvad er en Polyglot Notebook?

- `.dib` format (tidligere `.dotnet-interactive`)
- K√∏rer p√• .NET Interactive kernel
- Underst√∏tter flere sprog: C#, F#, HTML, Mermaid, PowerShell, JavaScript, SQL, KQL

### S√•dan k√∏rer du en celle

- **Shift+Enter** - K√∏r celle og g√• til n√¶ste
- **Ctrl+Enter** - K√∏r celle og bliv
- Variabler persisterer p√• tv√¶rs af celler

#!csharp

Console.WriteLine("Hello EV World!");

#!markdown

---

## Det Agentiske Landskab

<img src="images/Orloff-1600x1067.webp" alt="Professor Orloff" width="600" style="max-width: 100%;">
<br><br>

> An LLM is just a brain in a jar. üß†

‚Äî [Simon Maple](https://www.linkedin.com/in/simonmaple/), Head of Developer Relations @ Tessl ([AI Native podcast](https://open.spotify.com/episode/1HYcUlgkCa9VwvVfuy3fyx?nd=1&dlsi=a77f69fabf8b46b1))

### Hvorfor kan LLM'er kode s√• godt nu?

**Kode har indbygget feedback.** Til forskel fra "god tekst" kan vi objektivt m√•le om kode virker:
- Kompilerer det? ‚úÖ/‚ùå
- Best√•r tests? ‚úÖ/‚ùå
- L√∏ser det opgaven? ‚úÖ/‚ùå

Dette muligg√∏r **RLVR** (*Reinforcement Learning with Verifiable Rewards*):

<img src="images/ai-training-loop.svg" alt="AI Tr√¶ningsloop" width="600" style="max-width: 100%;">

#!markdown

### Benchmarks (pr. januar 2026)

#### SWE-bench: L√∏s rigtige GitHub issues

**SWE-bench Verified** (500 human-validerede issues):

| # | Model | Score |
|---|-------|-------|
| 1 | Claude Opus 4.5 | 80.9% |
| 2 | GPT-5.2 | 75.4% |
| 3 | Claude Opus 4.1 | 74.5% |

**SWE-bench Pro** (1865 sv√¶rere issues, nye repos):

| # | Agent | Score |
|---|-------|-------|
| 1 | Claude Opus 4.5 | 45.9% |
| 2 | Claude Sonnet 4.5 | 43.6% |
| 3 | Gemini 3 Pro Preview | 43.3% |

[swebench.com](https://www.swebench.com/)

---

#### METR: Hvor lang tid kan AI arbejde selvst√¶ndigt?

METR m√•ler **tidshorisonten** - hvor lange opgaver kan AI l√∏se med 50% succes?

| # | Model | 50% Tidshorisont |
|---|-------|------------------|
| 1 | Claude Opus 4.5 | ~4.8 timer |
| 2 | GPT-5.1 Codex Max | ~2.9 timer |
| 3 | GPT-5 | ~2.3 timer |

<br><img src="images/metr-timeline.svg" alt="METR Tidslinje" width="600" style="max-width: 100%;">

**Bem√¶rk:**
- Tidshorisonten **fordobles hver 7. m√•ned** (konsistent over 6 √•r, dvs. en pendant til Moore's Law)

**Hvis trenden forts√¶tter:**
- 2-4 √•r: ugelange opgaver
- √Örtiet ud: m√•nedlange projekter

[metr.org](https://metr.org/blog/2025-03-19-measuring-ai-ability-to-complete-long-tasks/)

---

#### DPAI Arena: Full developer workflow

JetBrains' benchmark - evaluerer hele engineering lifecycle p√• Spring-projekter (140+ opgaver).

| # | Agent | Model | Score |
|---|-------|-------|-------|
| 1 | Junie CLI 533.2 | Claude Opus 4.5 | 68.9 |
| 2 | Claude Code 2.0.55 | Claude Opus 4.5 | 68.0 |
| 3 | Junie CLI 496.3-prototype | Claude Sonnet 4.5 | 68.0 |

[dpaia.dev](https://dpaia.dev/)

---

### Men pas p√•: Benchmark ‚â† virkelighed

METR-studie (juli 2025):
- Erfarne udviklere *troede* de var **20% hurtigere** med AI, n√•r objektive tests viste de var **19% langsommere**

Sikkerhedss√•rbarheder ([Stanford/Boneh 2023](https://arxiv.org/abs/2211.03622)):
- Mennesker uden AI: **~50%** s√•rbar kode
- Mennesker MED AI: **~64%** ‚Äî faktisk **v√¶rre**!

Forskning tager lang tid og der innoveres med lynets hast, s√• det handler i h√∏j grad om at etablere et v√¶ddem√•l.

#!markdown

## Prerequisites Verification

#!markdown

### 1. Er Ollama installeret og k√∏rende?

#!csharp

// Test: Kan vi n√• Ollama?
using System.Net.Http;

var httpClient = new HttpClient();
string selectedModelName = "llama3.1:8b";

try
{
    var response = await httpClient.GetStringAsync("http://localhost:11434/api/tags");
    Console.WriteLine($"‚úÖ Ollama k√∏rer! Model: {selectedModelName}");
}
catch
{
    Console.WriteLine("‚ùå Ollama k√∏rer IKKE. Start med: ollama serve");
}

#!markdown

---

# Del 1: Agenter - teori og byg din egen
*70 minutter inkl. √∏velser*

> **"The LLM never actually touches your filesystem. It just *asks* for things to happen."**
> ‚Äî Mihail Eric, ["The Emperor Has No Clothes"](https://www.mihaileric.com/The-Emperor-Has-No-Clothes/)

AI coding assistants virker som magi, men kernen er simpel:
- **~200 linjer kode** er alt der skal til
- LLM beslutter hvad der skal ske
- **Din kode** udf√∏rer handlingerne lokalt
- Resultater sendes tilbage til LLM

### The Agentic Loop - 4 Steps

<img src="images/agentic-loop.svg" alt="Agentic Loop" width="600" style="max-width: 100%;">

**N√∏gleindsigt:** LLM'en kalder aldrig noget. Den outputter JSON der siger "Jeg vil gerne kalde X med Y". **Vi** eksekverer det!

#!markdown

## 1.1 Hvad LLM'en Faktisk Ser

Lad os se pr√¶cis hvad der sendes til Ollama.

#!csharp

// Dette er PR√ÜCIS hvad vi sender til Ollama som tool definition. Det er bare JSON der beskriver en funktion.

var toolJsonExample = """
{
  "type": "function",
  "function": {
    "name": "get_station_status",
    "description": "Get real-time status of an EV charging station",
    "parameters": {
      "type": "object",
      "properties": {
        "stationId": {
          "type": "string",
          "description": "The station ID, e.g., CPH-001"
        }
      },
      "required": ["stationId"]
    }
  }
}
""";

Console.WriteLine("Dette er hvad LLM'en ser som tool definition:");
Console.WriteLine(toolJsonExample);

#!csharp

// Og dette er hvad LLM'en returnerer n√•r den vil bruge et tool

var toolCallResponseExample = """
{
  "message": {
    "role": "assistant",
    "content": "",
    "tool_calls": [
      {
        "function": {
          "name": "get_station_status",
          "arguments": {
            "stationId": "CPH-001"
          }
        }
      }
    ]
  }
}
""";

Console.WriteLine("N√•r LLM'en vil kalde et tool, returnerer den:");
Console.WriteLine(toolCallResponseExample);
Console.WriteLine("\nLLM'en eksekverer ikke noget - den beder os om at g√∏re det!");

#!markdown

## 1.2 SimpleTool - Den Transparente Abstraktion

Nu bygger vi vores egen tool-definition.

**Forskellen p√• SimpleTool og OllamaSharp's indbyggede Tool:**
- `SimpleTool` har en `Execute` funktion - du kan se pr√¶cis hvad der k√∏rer
- `OllamaSharp.Tool` er kun en data-struktur for JSON serialisering, dvs. "automagi"

#!csharp

using System.Text.Json;

record SimpleTool(
    string Name,
    string Description,
    string ParameterSchema,           // Raw JSON
    Func<JsonElement, string> Execute // Selve koden
);

Console.WriteLine($"‚úÖ {typeof(SimpleTool).Name} defineret!");

#!markdown

## 1.3 ChargeSmart Dom√¶ne - Mock Data

Vi arbejder med et fiktivt EV-ladenetv√¶rk i K√∏benhavn:

#!csharp

// Station data (med koordinater til √∏velse 4: get_nearest_station)
record StationInfo(string Id, string Name, string Location, int PowerKw, string Type, double Latitude, double Longitude);

var stations = new Dictionary<string, StationInfo>
{
    ["CPH-001"] = new("CPH-001", "N√∏rreport Station", "N√∏rreport", 150, "ultra-fast", 55.6839, 12.5715),
    ["CPH-002"] = new("CPH-002", "Fisketorvet Parking", "Fisketorvet", 50, "fast", 55.6692, 12.5519),
    ["CPH-003"] = new("CPH-003", "Tivoli Garage", "Tivoli", 50, "fast", 55.6736, 12.5681),
    ["CPH-004"] = new("CPH-004", "√òrestad Center", "√òrestad", 150, "ultra-fast", 55.6310, 12.5770),
    ["CPH-005"] = new("CPH-005", "Amager Strandpark", "Amager", 22, "slow", 55.6520, 12.6050),
    ["CPH-006"] = new("CPH-006", "N√∏rrebro Runddel", "N√∏rrebro", 50, "fast", 55.7015, 12.5450),
    ["CPH-007"] = new("CPH-007", "Frederiksberg Have", "Frederiksberg", 7, "slow", 55.6784, 12.5293),
    ["CPH-008"] = new("CPH-008", "Kastrup Lufthavn P4", "Kastrup", 150, "ultra-fast", 55.6180, 12.6560),
    ["CPH-009"] = new("CPH-009", "Valby Langgade", "Valby", 22, "slow", 55.6631, 12.5120),
    ["CPH-010"] = new("CPH-010", "Hellerup Station", "Hellerup", 50, "fast", 55.7280, 12.5720),
};

// Simuler aktive sessioner
var activeSessions = new Dictionary<string, (string vehicleId, DateTime start, double kwh)>
{
    ["CPH-002"] = ("Tesla-Model-3", DateTime.Now.AddMinutes(-45), 28.5),
    ["CPH-004"] = ("Polestar-2", DateTime.Now.AddMinutes(-12), 18.2),
    ["CPH-007"] = ("VW-ID4", DateTime.Now.AddHours(-2), 11.0),
};

// Tarif struktur
decimal GetTariff(int hour) => hour switch
{
    >= 0 and < 6 => 1.50m,      // Off-peak: 00:00-06:00
    >= 6 and < 17 => 2.50m,     // Normal: 06:00-17:00
    >= 17 and < 21 => 4.00m,    // Peak: 17:00-21:00
    >= 21 and <= 23 => 2.50m,   // Normal: 21:00-00:00
    _ => 2.50m
};

Console.WriteLine($"‚úÖ Loaded {stations.Count} stationer, {activeSessions.Count} aktive sessioner");

#!markdown

## 1.4 √òvelse 1: Forst√• Execute-funktionerne til ChargeSmart Tools
*~15 minutter*

Nu skal du **forst√• og evt. modificere** `Execute`-funktionerne for 3 ChargeSmart tools.

**üìã Opgave:** F√∏r du k√∏rer cellen nedenfor:
1. L√¶s koden igennem og forst√• hvad hver funktion g√∏r
2. Pr√∏v at skjule koden og skrive din egen version (brug hints nedenfor)
3. Sammenlign med l√∏sningen og k√∏r cellen

**Du har adgang til:**
- `stations` - Dictionary med alle stationer (ID ‚Üí StationInfo)
- `activeSessions` - Dictionary med aktive sessioner (stationId ‚Üí session info)
- `GetTariff(int hour)` - Returnerer pris pr. kWh for en given time

**Krav til de 3 tools:**

| Tool | Input | Output |
|------|-------|--------|
| `get_station_status` | stationId (string) | Status p√• √©n station (ledig/optaget, kW, type) |
| `list_stations` | *ingen* | Liste over alle stationer med status |
| `calculate_charging_cost` | kwh (number), hour (int) | Pris for at lade X kWh p√• tidspunkt Y |

#!csharp

// üéØ √òVELSE 1: Studer disse Execute-funktioner!
// Tip: args er et JsonElement - brug args.GetProperty("name").GetString() osv.

var tools = new Dictionary<string, SimpleTool>
{
    ["get_station_status"] = new(
        Name: "get_station_status",
        Description: "Get real-time status of an EV charging station including availability, power level, and current session info",
        ParameterSchema: """{"type":"object","properties":{"stationId":{"type":"string","description":"Station ID like CPH-001"}},"required":["stationId"]}""",
        Execute: args =>
        {
            // 1. Hent stationId fra args
            var stationId = args.GetProperty("stationId").GetString()!;

            // 2. Sl√• op i stations dictionary
            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            // 3. Tjek om der er en aktiv session
            var hasSession = activeSessions.TryGetValue(stationId, out var session);

            // 4. Returner beskrivende streng
            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
                : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        }
    ),

    ["list_stations"] = new(
        Name: "list_stations",
        Description: "List all EV charging stations in the ChargeSmart network with their current availability",
        ParameterSchema: """{"type":"object","properties":{}}""",
        Execute: _ =>
        {
            // LINQ til at formatere alle stationer
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        }
    ),

    ["calculate_charging_cost"] = new(
        Name: "calculate_charging_cost",
        Description: "Calculate the cost of charging based on kWh needed and time of day",
        ParameterSchema: """{"type":"object","properties":{"kwh":{"type":"number","description":"Energy needed in kWh"},"hour":{"type":"integer","description":"Hour of day (0-23)"}},"required":["kwh","hour"]}""",
        Execute: args =>
        {
            // Handle both number and string JSON values from LLM
            var kwhProp = args.GetProperty("kwh");
            var hourProp = args.GetProperty("hour");
            var kwh = kwhProp.ValueKind == JsonValueKind.String
                ? double.Parse(kwhProp.GetString()!, System.Globalization.CultureInfo.InvariantCulture)
                : kwhProp.GetDouble();
            var hour = hourProp.ValueKind == JsonValueKind.String
                ? int.Parse(hourProp.GetString()!)
                : hourProp.GetInt32();
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;

            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };

            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        }
    )
};

Console.WriteLine($"‚úÖ Defineret {tools.Count} tools:");
foreach (var tool in tools.Values)
{
    Console.WriteLine($"   - {tool.Name}: {tool.Description.Substring(0, Math.Min(50, tool.Description.Length))}...");
}

#!markdown

### Hints til √òvelse 1

<details>
<summary>üí° Hint 1: S√•dan l√¶ser du fra JsonElement</summary>

```csharp
// Hent en string property
var stationId = args.GetProperty("stationId").GetString()!;

// Hent et tal (kan v√¶re string eller number i JSON)
var kwhProp = args.GetProperty("kwh");
var kwh = kwhProp.ValueKind == JsonValueKind.String
    ? double.Parse(kwhProp.GetString()!, System.Globalization.CultureInfo.InvariantCulture)
    : kwhProp.GetDouble();
```

</details>

<details>
<summary>üí° Hint 2: get_station_status struktur</summary>

```csharp
Execute: args =>
{
    var stationId = args.GetProperty("stationId").GetString()!;

    if (!stations.TryGetValue(stationId, out var station))
        return $"Error: Station {stationId} not found";

    var hasSession = activeSessions.TryGetValue(stationId, out var session);

    // Returner forskellige beskeder baseret p√• hasSession
    return hasSession
        ? $"Station {stationId}: IN USE..."
        : $"Station {stationId}: AVAILABLE...";
}
```

</details>

<details>
<summary>üí° Hint 3: list_stations med LINQ</summary>

```csharp
Execute: _ =>
{
    var lines = stations.Values.Select(s =>
    {
        var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
        return $"- {s.Id}: {s.Name} - {status}";
    });
    return string.Join("\n", lines);
}
```

</details>

<details>
<summary>‚úÖ Fuld l√∏sning: Alle 3 tools</summary>

```csharp
var tools = new Dictionary<string, SimpleTool>
{
    ["get_station_status"] = new(
        Name: "get_station_status",
        Description: "Get real-time status of an EV charging station including availability, power level, and current session info",
        ParameterSchema: """{"type":"object","properties":{"stationId":{"type":"string","description":"Station ID like CPH-001"}},"required":["stationId"]}""",
        Execute: args =>
        {
            var stationId = args.GetProperty("stationId").GetString()!;

            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            var hasSession = activeSessions.TryGetValue(stationId, out var session);

            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
                : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        }
    ),

    ["list_stations"] = new(
        Name: "list_stations",
        Description: "List all EV charging stations in the ChargeSmart network with their current availability",
        ParameterSchema: """{"type":"object","properties":{}}""",
        Execute: _ =>
        {
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        }
    ),

    ["calculate_charging_cost"] = new(
        Name: "calculate_charging_cost",
        Description: "Calculate the cost of charging based on kWh needed and time of day",
        ParameterSchema: """{"type":"object","properties":{"kwh":{"type":"number","description":"Energy needed in kWh"},"hour":{"type":"integer","description":"Hour of day (0-23)"}},"required":["kwh","hour"]}""",
        Execute: args =>
        {
            var kwhProp = args.GetProperty("kwh");
            var hourProp = args.GetProperty("hour");
            var kwh = kwhProp.ValueKind == JsonValueKind.String
                ? double.Parse(kwhProp.GetString()!, System.Globalization.CultureInfo.InvariantCulture)
                : kwhProp.GetDouble();
            var hour = hourProp.ValueKind == JsonValueKind.String
                ? int.Parse(hourProp.GetString()!)
                : hourProp.GetInt32();
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;

            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };

            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        }
    )
};
```

</details>

#!markdown

### Verificer din l√∏sning

K√∏r cellen nedenfor for at teste dine Execute-funktioner **uden LLM**:

#!csharp

// Test dine tools direkte!
Console.WriteLine("=== Test get_station_status ===");
var args1 = JsonDocument.Parse("""{"stationId": "CPH-001"}""").RootElement;
Console.WriteLine(tools["get_station_status"].Execute(args1));
Console.WriteLine();

Console.WriteLine("=== Test list_stations ===");
var args2 = JsonDocument.Parse("{}").RootElement;
Console.WriteLine(tools["list_stations"].Execute(args2));
Console.WriteLine();

Console.WriteLine("=== Test calculate_charging_cost ===");
var args3 = JsonDocument.Parse("""{"kwh": 50, "hour": 18}""").RootElement;
Console.WriteLine(tools["calculate_charging_cost"].Execute(args3));
Console.WriteLine();

Console.WriteLine("‚úÖ Alle tests k√∏rte! Hvis du ser output ovenfor, virker dine tools.");

#!markdown

## 1.5 The Agentic Loop - ~50 Lines - det er det hele 

Nu bygger vi det komplette agentic loop fra bunden. Vi skal blot f√∏rst overs√¶tte vores SimpleTool til OllamaSharp's Tool-type.

#!csharp

#r "nuget: OllamaSharp, 5.3.4"

using OllamaSharp;
using OllamaSharp.Models;
using OllamaSharp.Models.Chat;

Console.WriteLine("‚úÖ OllamaSharp loaded!");

#!csharp

// Hj√¶lpefunktion: Konverter SimpleTool til Ollama's Tool format
Tool ToOllamaFormat(SimpleTool simpleTool)
{
    var schemaDoc = JsonDocument.Parse(simpleTool.ParameterSchema);
    var props = schemaDoc.RootElement.GetProperty("properties");
    var required = schemaDoc.RootElement.TryGetProperty("required", out var req)
        ? req.EnumerateArray().Select(x => x.GetString()!).ToArray()
        : Array.Empty<string>();

    var properties = new Dictionary<string, Property>();
    foreach (var prop in props.EnumerateObject())
    {
        properties[prop.Name] = new Property
        {
            Type = prop.Value.GetProperty("type").GetString(),
            Description = prop.Value.TryGetProperty("description", out var desc) ? desc.GetString() : null
        };
    }

    return new Tool
    {
        Type = "function",
        Function = new Function
        {
            Name = simpleTool.Name,
            Description = simpleTool.Description,
            Parameters = new Parameters
            {
                Type = "object",
                Properties = properties,
                Required = required
            }
        }
    };
}

Console.WriteLine("‚úÖ ToOllamaFormat helper defined");

#!csharp

// THE AGENTIC LOOP - ~50 lines, no magic!
async Task<string> RunAgent(string userMessage, Dictionary<string, SimpleTool> tools)
{
    var ollama = new OllamaApiClient("http://localhost:11434");

    var messages = new List<Message>
    {
        new Message
        {
            Role = OllamaSharp.Models.Chat.ChatRole.System,
            Content = """
                Du er en hj√¶lpsom EV-ladnings assistent for ChargeSmart netv√¶rket i K√∏benhavn.
                Brug de tilg√¶ngelige tools til at besvare sp√∏rgsm√•l om ladestationer,
                tilg√¶ngelighed, og priser. Svar altid p√• dansk.
                """
        },
        new Message { Role = OllamaSharp.Models.Chat.ChatRole.User, Content = userMessage }
    };

    var ollamaTools = tools.Values.Select(ToOllamaFormat).ToList();
    var maxIterations = 10;
    var iteration = 0;

    while (iteration < maxIterations)
    {
        iteration++;
        Console.WriteLine($"\n--- Iteration {iteration} ---");

        // 1. Send til Ollama med tool-definitioner
        var request = new ChatRequest
        {
            Model = selectedModelName ?? "llama3.1:8b",
            Messages = messages,
            Tools = ollamaTools,
            Stream = false
        };

        ChatResponseStream? response = null;
        await foreach (var chunk in ollama.ChatAsync(request))
        {
            response = chunk;
        }

        var assistantMessage = response?.Message;
        if (assistantMessage == null)
            return "Error: No response from LLM";

        messages.Add(assistantMessage);

        // 2. Tjek for tool calls
        if (assistantMessage.ToolCalls == null || !assistantMessage.ToolCalls.Any())
        {
            // Ingen tool calls = LLM er f√¶rdig
            Console.WriteLine("‚úÖ LLM finished (no tool calls)");
            return assistantMessage.Content ?? "No response";
        }

        // 3. Eksekv√©r hver tool call SELV
        Console.WriteLine($"üîß LLM wants to call {assistantMessage.ToolCalls.Count()} tool(s)");

        foreach (var toolCall in assistantMessage.ToolCalls)
        {
            var toolName = toolCall.Function?.Name ?? "unknown";
            Console.WriteLine($"   Tool: {toolName}");
            Console.WriteLine($"   Args: {JsonSerializer.Serialize(toolCall.Function?.Arguments)}");

            // Find og k√∏r vores SimpleTool
            if (tools.TryGetValue(toolName, out var tool) && toolCall.Function?.Arguments != null)
            {
                // Konverter arguments til JsonElement
                var argsJson = JsonSerializer.Serialize(toolCall.Function.Arguments);
                var argsElement = JsonDocument.Parse(argsJson).RootElement;

                var result = tool.Execute(argsElement);  // <-- DIN kode k√∏rer her!
                Console.WriteLine($"   üì§ Result: {result.Substring(0, Math.Min(80, result.Length))}...");

                // 4. Tilf√∏j resultat til messages
                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = result
                });
            }
            else
            {
                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = $"Error: Unknown tool {toolName}"
                });
            }
        }
        // Loop forts√¶tter - LLM ser resultaterne
    }

    return "Max iterations reached";
}

Console.WriteLine("‚úÖ RunAgent function defined (~50 lines)");

#!markdown

## 1.6 √òvelse 2: Human-in-the-Loop Confirmation
*~15 minutter*

I produktion vil du ofte have tools der g√∏r "farlige" ting - f.eks. starter en ladesession, foretager en betaling, eller sletter data. F√∏r s√•danne tools eksekveres, b√∏r agenten **bede om bekr√¶ftelse**.

**Scenarie:** Forestil dig at `calculate_charging_cost` kunne udl√∏se en forh√•ndsreservation eller pre-authorization p√• dit kort. F√∏r vi eksekverer det, vil vi gerne have brugerens godkendelse.

**Din opgave:** Modificer loopet s√• det beder om bekr√¶ftelse f√∏r "farlige" tools eksekveres.

#!csharp

// üéØ √òVELSE 2: Tilf√∏j human-in-the-loop confirmation

using Microsoft.DotNet.Interactive;

// Definer hvilke tools der kr√¶ver bekr√¶ftelse
var dangerousTools = new HashSet<string> { "calculate_charging_cost" };

// RunAgentWithConfirmation - n√¶sten identisk med RunAgent!
// Bruger Kernel.GetInputAsync() til at vise en VS Code dialog
async Task<string> RunAgentWithConfirmation(
    string userMessage,
    Dictionary<string, SimpleTool> tools)
{
    var ollama = new OllamaApiClient("http://localhost:11434");

    var messages = new List<Message>
    {
        new Message
        {
            Role = OllamaSharp.Models.Chat.ChatRole.System,
            Content = """
                Du er en hj√¶lpsom EV-ladnings assistent for ChargeSmart netv√¶rket i K√∏benhavn.
                Brug de tilg√¶ngelige tools til at besvare sp√∏rgsm√•l om ladestationer,
                tilg√¶ngelighed, og priser. Svar altid p√• dansk.
                """
        },
        new Message { Role = OllamaSharp.Models.Chat.ChatRole.User, Content = userMessage }
    };

    var ollamaTools = tools.Values.Select(ToOllamaFormat).ToList();
    var maxIterations = 10;
    var iteration = 0;

    while (iteration < maxIterations)
    {
        iteration++;
        Console.WriteLine($"\n--- Iteration {iteration} ---");

        var request = new ChatRequest
        {
            Model = selectedModelName ?? "llama3.1:8b",
            Messages = messages,
            Tools = ollamaTools,
            Stream = false
        };

        ChatResponseStream? response = null;
        await foreach (var chunk in ollama.ChatAsync(request))
        {
            response = chunk;
        }

        var assistantMessage = response?.Message;
        if (assistantMessage == null)
            return "Error: No response from LLM";

        messages.Add(assistantMessage);

        if (assistantMessage.ToolCalls == null || !assistantMessage.ToolCalls.Any())
        {
            Console.WriteLine("‚úÖ LLM finished (no tool calls)");
            return assistantMessage.Content ?? "No response";
        }

        Console.WriteLine($"üîß LLM wants to call {assistantMessage.ToolCalls.Count()} tool(s)");

        foreach (var toolCall in assistantMessage.ToolCalls)
        {
            var toolName = toolCall.Function?.Name ?? "unknown";
            var argsJson = JsonSerializer.Serialize(toolCall.Function?.Arguments);
            Console.WriteLine($"   Tool: {toolName}");
            Console.WriteLine($"   Args: {argsJson}");

            // üéØ √òVELSE: Tilf√∏j bekr√¶ftelseslogik her!
            // Hvis toolName er i dangerousTools:
            //   - Brug await Kernel.GetInputAsync() til at sp√∏rge brugeren
            //   - Hvis svaret ikke er "y", skip dette tool call med continue

            if (tools.TryGetValue(toolName, out var tool) && toolCall.Function?.Arguments != null)
            {
                var argsElement = JsonDocument.Parse(argsJson).RootElement;
                var result = tool.Execute(argsElement);
                Console.WriteLine($"   üì§ Result: {result.Substring(0, Math.Min(80, result.Length))}...");

                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = result
                });
            }
            else
            {
                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = $"Error: Unknown tool {toolName}"
                });
            }
        }
    }

    return "Max iterations reached";
}

#!markdown

### Om Kernel.GetInputAsync()

`Kernel.GetInputAsync()` er .NET Interactives m√•de at f√• bruger-input i Polyglot Notebooks. Den √•bner en **VS Code input dialog** hvor brugeren kan skrive svar.

<details>
<summary>üí° Reference: Bekr√¶ftelseslogikken</summary>

```csharp
// Tjek om tool er "farligt" og bed om bekr√¶ftelse
if (dangerousTools.Contains(toolName))
{
    var confirmation = await Kernel.GetInputAsync($"‚ö†Ô∏è Execute '{toolName}'? (y/n):");
    if (confirmation?.Trim().ToLower() != "y")
    {
        Console.WriteLine("   ‚è≠Ô∏è Skipped by user");
        messages.Add(new Message
        {
            Role = OllamaSharp.Models.Chat.ChatRole.Tool,
            Content = $"Tool {toolName} was skipped by user"
        });
        continue;  // Skip til n√¶ste tool call
    }
    Console.WriteLine("   ‚úÖ Confirmed by user");
}
```

**L√¶rdom:** Human-in-the-loop er kritisk for produktions-agents. Du bestemmer hvilke handlinger der kr√¶ver godkendelse!

</details>

#!markdown

### Test din l√∏sning

K√∏r cellen nedenfor. N√•r LLM vil kalde `calculate_charging_cost`, vil VS Code vise en input dialog. Skriv `y` for at godkende eller `n` for at afvise.

#!csharp

// Test human-in-the-loop - VS Code vil vise en dialog!
var result = await RunAgentWithConfirmation(
    "Hvad koster det at lade 50 kWh kl. 18?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result);

#!markdown

## 1.7 Test din Agent!

#!csharp

var result = await RunAgent(
    "Hvilke ladestationer er ledige lige nu?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result);

#!csharp

var result2 = await RunAgent(
    "Hvad er status p√• CPH-002?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result2);

#!csharp

var result3 = await RunAgent(
    "Hvad koster det at lade 50 kWh kl. 18? Og hvad hvis jeg venter til kl. 22?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result3);

#!markdown

## Checkpoint Del 1

Du har nu:
1. ‚úÖ Set pr√¶cis hvad LLM'en modtager (JSON tool definitions)
2. ‚úÖ Set pr√¶cis hvad LLM'en returnerer (JSON tool calls)
3. ‚úÖ Bygget `SimpleTool` - en transparent tool abstraction
4. ‚úÖ **√òvelse 1:** Skrevet Execute-funktioner til 3 ChargeSmart tools
5. ‚úÖ Set det komplette agentic loop (~50 linjer!)
6. ‚úÖ **√òvelse 2:** Tilf√∏jet human-in-the-loop confirmation til loopet
7. ‚úÖ K√∏rt en agent med dine tools

**N√∏gleindsigt:** Det er s√• simpelt. ~50 linjer loop + ~10 linjer per tool. *The emperor has no clothes!*

**L√¶rdom fra √òvelse 2:** I produktion er human-in-the-loop kritisk. Du bestemmer hvilke handlinger der kr√¶ver godkendelse!

---

#!markdown

# Del 2: Abstraktionsstigen ‚Äì OllamaSharp.Tool
*15 minutter (valgfri)*

Nu hvor du forst√•r hvad der sker "under the hood", lad os se hvordan OllamaSharp pakker det samme.

#!markdown

## 2.1 Side-by-Side: SimpleTool vs OllamaSharp.Tool

#!csharp

// DIN SimpleTool - alt er synligt:
var simpleToolExample = new SimpleTool(
    Name: "get_station_status",
    Description: "Get EV charging station status",
    ParameterSchema: """{"type":"object","properties":{"stationId":{"type":"string"}},"required":["stationId"]}""",
    Execute: args => $"Station {args.GetProperty("stationId").GetString()} is available"  // <-- Koden er HER
);

// OllamaSharp's Tool - samme data, anden struktur:
var ollamaToolExample = new Tool
{
    Type = "function",
    Function = new Function
    {
        Name = "get_station_status",
        Description = "Get EV charging station status",
        Parameters = new Parameters
        {
            Type = "object",
            Properties = new Dictionary<string, Property>
            {
                ["stationId"] = new Property { Type = "string", Description = "Station ID" }
            },
            Required = new[] { "stationId" }
        }
    }
};
// BEM√ÜRK: Ingen Execute property! Du skal h√•ndtere eksekveringen separat i dit loop.

Console.WriteLine("SimpleTool har:");
Console.WriteLine("  - Name, Description, ParameterSchema");
Console.WriteLine("  - Execute: Func<JsonElement, string> ‚Üê KODEN ER HER");
Console.WriteLine();
Console.WriteLine("OllamaSharp.Tool har:");
Console.WriteLine("  - Type, Function (Name, Description, Parameters)");
Console.WriteLine("  - Ingen Execute! ‚Üê Du skal selv matche tool calls til kode");

#!markdown

## 2.2 N√∏gleindsigt

**OllamaSharp's Tool er bare en data-struktur til JSON-serialisering.**

Det er derfor vi byggede `SimpleTool` f√∏rst - for at se det fulde billede:
1. Tool *definition* (JSON schema) ‚Üí sendes til LLM
2. Tool *execution* (din kode) ‚Üí k√∏rer lokalt n√•r LLM requester det

Libraries som OllamaSharp giver dig #1, men du skal selv h√•ndtere #2.
Vores `SimpleTool` pakker begge dele sammen s√• det er tydeligt.

#!markdown

## 2.3 √òvelse: Refaktorer til OllamaSharp.Tool

Konverter √©n af dine SimpleTool definitioner til OllamaSharp.Tool format.
Behold samme execution logic i dit loop.

<details>
<summary>Hint: Se l√∏sningen</summary>

```csharp
// SimpleTool version:
var getStatus = new SimpleTool(
    Name: "get_station_status",
    // ...
    Execute: args => { /* kode */ }
);

// OllamaSharp version:
var getStatusTool = new Tool {
    Function = new Function {
        Name = "get_station_status",
        // ... (ingen Execute!)
    }
};

// Execution h√•ndteres separat i loop:
if (toolCall.Function.Name == "get_station_status")
{
    result = /* din execution kode */;
}
```

</details>

#!markdown

---

# ‚òï PAUSE (15 min)

---

#!markdown

# Del 3: Abstraktionsstigen ‚Äì MCP
*45 minutter inkl. √∏velse*

Vi forts√¶tter op ad abstraktionsstigen: SimpleTool ‚Üí OllamaSharp.Tool ‚Üí **MCP**.

## Teori: Model Context Protocol (MCP)

### Problemet: N√óM Integrationer

<img src="images/mcp-problem.svg" alt="MCP Problem" width="600" style="max-width: 100%;">

Uden standardisering: Hver agent skal have custom integration til hver tool.

### L√∏sningen: MCP som Standard

<img src="images/mcp-solution.svg" alt="MCP Solution" width="600" style="max-width: 100%;">

**MCP = USB-C for AI tools.** *Plug any tool into any agent.*

#!markdown

## 3.1 Hvad √Ündrer Sig med MCP?

**F√∏r (Del 1-2):** Tools defineret inline i din kode
```csharp
var tools = new Dictionary<string, SimpleTool> {
    ["get_station_status"] = new SimpleTool(..., Execute: args => ...)
};
// Tools lever i din agent kode
```

**Efter (Del 3):** Tools kommer fra eksterne MCP servere
```csharp
var mcpClient = await McpClient.CreateAsync(transport);
var tools = await mcpClient.ListToolsAsync();
// Tools opdages dynamisk fra server!
```

**Samme agent loop, men tools er *"pluggable"*.**

#!markdown

## 3.2 MCP Protocol Basics

MCP bruger **JSON-RPC 2.0** over stdio (lokalt) eller SSE (remote).

Tre hovedoperationer:
1. `initialize` - Handshake mellem client og server
2. `tools/list` - Hent liste af tilg√¶ngelige tools
3. `tools/call` - Kald et specifikt tool

#!csharp

// Microsoft.Extensions.AI for AIFunctionFactory
#r "nuget: Microsoft.Extensions.AI, 9.5.0"

using Microsoft.Extensions.AI;

Console.WriteLine("‚úÖ Microsoft.Extensions.AI indl√¶st!");

#!markdown

## 3.3 √òvelse 3: AIFunction Tools med Microsoft.Extensions.AI
*~10 minutter*

MCP er designet til **inter-proces** kommunikation (client og server i separate processer).
I en notebook bruger vi i stedet `AIFunctionFactory` fra Microsoft.Extensions.AI, som giver samme tool-oplevelse **in-process**.

> **Note:** I produktion ville du forbinde til en ekstern MCP server via `StdioClientTransport` eller `HttpClientTransport`.

**üìã Opgave:** Sammenlign `AIFunctionFactory.Create()` med `SimpleTool`:
- I √òvelse 1 brugte du `SimpleTool` med `Execute: args => { ... }` (JsonElement)
- Her bruger du `AIFunctionFactory.Create((param) => { ... }, "name", "description")`
- Parametrene er **typed** (string, int, double) i stedet for JsonElement!

**Bem√¶rk:** Logikken er den samme - kun signaturen er anderledes.

#!csharp

// üéØ √òVELSE 3: Opret AIFunction tools
// Du kender allerede logikken fra √òvelse 1 - nu skal du bare bruge en anden signatur!

var aiTools = new List<AITool>
{
    // Eksempel: get_station_status er givet
    AIFunctionFactory.Create(
        (string stationId) =>
        {
            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            var hasSession = activeSessions.TryGetValue(stationId, out var session);
            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
                : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        },
        "get_station_status",
        "Get real-time status of an EV charging station. Parameter: stationId (e.g. CPH-001)"),

    // list_stations - studer denne implementering
    AIFunctionFactory.Create(
        () =>
        {
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        },
        "list_stations",
        "List all EV charging stations in the ChargeSmart network with their current availability"),

    // calculate_charging_cost - studer denne implementering
    AIFunctionFactory.Create(
        (double kwh, int hour) =>
        {
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;
            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };
            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        },
        "calculate_charging_cost",
        "Calculate the cost of charging based on kWh needed and hour of day (0-23)")
};

Console.WriteLine($"üîå Oprettet {aiTools.Count} AIFunction tools:");

#!markdown

### Hints til √òvelse 3

<details>
<summary>üí° Hint: list_stations</summary>

```csharp
AIFunctionFactory.Create(
    () =>
    {
        var lines = stations.Values.Select(s =>
        {
            var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
            return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
        });
        return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
    },
    "list_stations",
    "List all EV charging stations...")
```

</details>

<details>
<summary>üí° Hint: calculate_charging_cost</summary>

```csharp
AIFunctionFactory.Create(
    (double kwh, int hour) =>
    {
        var tariff = GetTariff(hour);
        var cost = (decimal)kwh * tariff;
        var period = hour switch
        {
            >= 0 and < 6 => "off-peak",
            >= 17 and < 21 => "peak",
            _ => "normal"
        };
        return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
    },
    "calculate_charging_cost",
    "Calculate the cost of charging...")
```

</details>

<details>
<summary>‚úÖ Fuld l√∏sning: Alle 3 AIFunction tools</summary>

```csharp
var aiTools = new List<AITool>
{
    AIFunctionFactory.Create(
        (string stationId) =>
        {
            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            var hasSession = activeSessions.TryGetValue(stationId, out var session);
            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
                : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        },
        "get_station_status",
        "Get real-time status of an EV charging station. Parameter: stationId (e.g. CPH-001)"),

    AIFunctionFactory.Create(
        () =>
        {
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        },
        "list_stations",
        "List all EV charging stations in the ChargeSmart network with their current availability"),

    AIFunctionFactory.Create(
        (double kwh, int hour) =>
        {
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;
            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };
            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        },
        "calculate_charging_cost",
        "Calculate the cost of charging based on kWh needed and hour of day (0-23)")
};
```

</details>

#!markdown

## 3.4 IChatClient + UseFunctionInvocation()

Her kommer magien - eller rettere, **automationen af det loop du byggede i Del 1!**

OllamaSharp implementerer `IChatClient` fra Microsoft.Extensions.AI.
`UseFunctionInvocation()` automatiserer hele loop'et.

#!csharp

// OllamaApiClient IS an IChatClient!
var ollama = new OllamaApiClient("http://localhost:11434");
ollama.SelectedModel = selectedModelName ?? "llama3.1:8b";

// Wrap med automatisk function invocation
// Dette ER det agentic loop fra Del 1 - bare automatiseret!
IChatClient chatClient = new ChatClientBuilder(ollama)
    .UseFunctionInvocation()  // ‚Üê Automatiserer HELE loop'et fra Del 1
    .Build();

Console.WriteLine("‚úÖ IChatClient med UseFunctionInvocation() klar!");
Console.WriteLine("   - Modtager tool_calls fra LLM");
Console.WriteLine("   - Eksekverer tools automatisk");
Console.WriteLine("   - Sender resultater tilbage");
Console.WriteLine("   - Looper indtil f√¶rdig");

#!markdown

## 3.5 √òvelse: ChargeSmart med AIFunction Tools

K√∏r samme query som i Del 1, men nu med AIFunction tools og automatiseret loop!

**Bem√¶rk:** Samme tools, samme data - men nu via `IChatClient.UseFunctionInvocation()`.

#!csharp

Console.WriteLine("Sender besked med AIFunction tools...\n");

var messages = new List<ChatMessage>
{
    new(Microsoft.Extensions.AI.ChatRole.User, "Hvilke ladestationer er ledige lige nu? Og hvad koster det at lade 30 kWh kl. 18?")
};

// AIFunction tools + automatisk loop via IChatClient
await foreach (var update in chatClient.GetStreamingResponseAsync(
    messages,
    new() { Tools = [.. aiTools] }))
{
    Console.Write(update.Text);
}

Console.WriteLine("\n\n‚úÖ Done!")

#!markdown

## Checkpoint Del 3

Du har nu:
1. ‚úÖ Forst√•et MCP som "USB-C for AI tools"
2. ‚úÖ **√òvelse 3:** Oprettet tools med `AIFunctionFactory` fra Microsoft.Extensions.AI
3. ‚úÖ Set hvordan `IChatClient.UseFunctionInvocation()` automatiserer loop'et
4. ‚úÖ K√∏rt en agent med automatiseret tool invocation

**N√∏gleindsigt:** MCP standardiserer tool connectivity. I produktion forbinder du til eksterne MCP servere - i notebooks bruger vi `AIFunctionFactory` som in-process alternativ.

---

#!markdown

# Del 3.5: √òvelse 4 - Udvid med get_nearest_station
*~20 minutter*

Nu skal du **studere hvordan man udvider** agenten med et helt nyt tool! Dette er den vigtigste √∏velse, fordi det simulerer det typiske workflow: du har en fungerende agent og skal tilf√∏je ny funktionalitet.

## Scenarie

En bruger st√•r p√• gaden og vil finde den **n√¶rmeste ledige ladestation**. De kender deres GPS-koordinater og vil have en anbefaling.

**üìã Opgave:** Studer implementeringen nedenfor og forst√• logikken:
1. Modtag brugerens latitude og longitude
2. Filtrer alle **ledige** stationer (ikke optaget)
3. Beregn afstanden til hver station med Haversine
4. Returner den n√¶rmeste

## Stationskoordinater

Alle stationer har nu latitude/longitude (vi tilf√∏jede dem i starten):

| Station | Lokation | Latitude | Longitude |
|---------|----------|----------|-----------|
| CPH-001 | N√∏rreport | 55.6839 | 12.5715 |
| CPH-002 | Fisketorvet | 55.6692 | 12.5519 |
| CPH-003 | Tivoli | 55.6736 | 12.5681 |
| CPH-004 | √òrestad | 55.6310 | 12.5770 |
| CPH-005 | Amager | 55.6520 | 12.6050 |
| CPH-006 | N√∏rrebro | 55.7015 | 12.5450 |
| CPH-007 | Frederiksberg | 55.6784 | 12.5293 |
| CPH-008 | Kastrup | 55.6180 | 12.6560 |
| CPH-009 | Valby | 55.6631 | 12.5120 |
| CPH-010 | Hellerup | 55.7280 | 12.5720 |

#!csharp

// üéØ √òVELSE 4: Implementer get_nearest_station

// Haversine-formlen til at beregne afstand mellem to koordinater (i km)
double CalculateDistance(double lat1, double lon1, double lat2, double lon2)
{
    const double R = 6371; // Jordens radius i km
    var dLat = (lat2 - lat1) * Math.PI / 180;
    var dLon = (lon2 - lon1) * Math.PI / 180;
    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
            Math.Cos(lat1 * Math.PI / 180) * Math.Cos(lat2 * Math.PI / 180) *
            Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
    var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
    return R * c;
}

// Test: Afstand fra R√•dhuspladsen (55.6761, 12.5683) til N√∏rreport (CPH-001)
var testDistance = CalculateDistance(55.6761, 12.5683, 55.6839, 12.5715);
Console.WriteLine($"Test: Afstand fra R√•dhuspladsen til N√∏rreport: {testDistance:F2} km");

#!csharp

// get_nearest_station - studer denne implementering!

var getNearestStation = AIFunctionFactory.Create(
    (double latitude, double longitude) =>
    {
        // 1. Filtrer ledige stationer
        var availableStations = stations.Values
            .Where(s => !activeSessions.ContainsKey(s.Id))
            .ToList();

        if (!availableStations.Any())
            return "Ingen ledige stationer lige nu!";

        // 2. Find n√¶rmeste med LINQ
        var nearest = availableStations
            .Select(s => new {
                Station = s,
                Distance = CalculateDistance(latitude, longitude, s.Latitude, s.Longitude)
            })
            .OrderBy(x => x.Distance)
            .First();

        // 3. Returner beskrivende streng
        return $"N√¶rmeste ledige station: {nearest.Station.Id} ({nearest.Station.Name}) - " +
               $"{nearest.Distance:F2} km v√¶k. " +
               $"{nearest.Station.PowerKw}kW {nearest.Station.Type} charger ved {nearest.Station.Location}.";
    },
    "get_nearest_station",
    "Find the nearest available charging station. Parameters: latitude and longitude of user's current position"
);

// Tilf√∏j til aiTools
aiTools.Add(getNearestStation);
Console.WriteLine($"üîå aiTools har nu {aiTools.Count} tools (inkl. get_nearest_station)");

#!markdown

### Hints til √òvelse 4

<details>
<summary>üí° Hint 1: Filtrer ledige stationer</summary>

```csharp
var availableStations = stations.Values
    .Where(s => !activeSessions.ContainsKey(s.Id))
    .ToList();

if (!availableStations.Any())
    return "Ingen ledige stationer lige nu!";
```

</details>

<details>
<summary>üí° Hint 2: Beregn afstande og find minimum</summary>

```csharp
var nearest = availableStations
    .Select(s => new {
        Station = s,
        Distance = CalculateDistance(latitude, longitude, s.Latitude, s.Longitude)
    })
    .OrderBy(x => x.Distance)
    .First();
```

</details>

<details>
<summary>‚úÖ Fuld l√∏sning</summary>

```csharp
var getNearestStation = AIFunctionFactory.Create(
    (double latitude, double longitude) =>
    {
        // Filtrer ledige stationer
        var availableStations = stations.Values
            .Where(s => !activeSessions.ContainsKey(s.Id))
            .ToList();

        if (!availableStations.Any())
            return "Ingen ledige stationer lige nu!";

        // Find n√¶rmeste
        var nearest = availableStations
            .Select(s => new {
                Station = s,
                Distance = CalculateDistance(latitude, longitude, s.Latitude, s.Longitude)
            })
            .OrderBy(x => x.Distance)
            .First();

        return $"N√¶rmeste ledige station: {nearest.Station.Id} ({nearest.Station.Name}) - " +
               $"{nearest.Distance:F2} km v√¶k. " +
               $"{nearest.Station.PowerKw}kW {nearest.Station.Type} charger ved {nearest.Station.Location}.";
    },
    "get_nearest_station",
    "Find the nearest available charging station. Parameters: latitude and longitude of user's current position"
);
```

</details>

#!markdown

### Test dit nye tool

#!csharp

// Test get_nearest_station med en position n√¶r R√•dhuspladsen
Console.WriteLine("=== Test fra R√•dhuspladsen (55.6761, 12.5683) ===\n");

var messages = new List<ChatMessage>
{
    new(Microsoft.Extensions.AI.ChatRole.User,
        "Jeg st√•r p√• R√•dhuspladsen (koordinater: 55.6761, 12.5683). Hvor er den n√¶rmeste ledige ladestation?")
};

await foreach (var update in chatClient.GetStreamingResponseAsync(
    messages,
    new() { Tools = [.. aiTools] }))
{
    Console.Write(update.Text);
}

Console.WriteLine("\n\n‚úÖ Test f√¶rdig!");

#!markdown

## Checkpoint √òvelse 4

Du har nu:
1. ‚úÖ Forst√•et Haversine-formlen til afstandsberegning
2. ‚úÖ Implementeret `get_nearest_station` med LINQ og afstandssortering
3. ‚úÖ Udvidet en eksisterende agent med ny funktionalitet
4. ‚úÖ Testet med en realistisk brugerforesp√∏rgsel

**L√¶rdom:** At udvide en agent er ofte nemmere end at bygge en fra bunden. Du tilf√∏jer bare et nyt tool til listen!

---

#!markdown

# Del 4: Skills ‚Äì teori og pr√∏v med GitHub Copilot
*25 minutter*

## SEPARAT VEJ

> **Vigtigt:** Dette er en SEPARAT tilgang fra Del 1-3.
> - Del 1-3: Byg din egen agent med Ollama
> - Del 4: Udvid GitHub Copilot med dom√¶neviden

## Fra dom√¶ne-specifikke agents til universel kode

**Hvordan vi plejede at t√¶nke:**

<img src="images/anthropic-how-we-used-to-think-about-agents.png" alt="Separate agents for each domain" width="600" style="max-width: 100%;">

Vi troede hver dom√¶ne kr√¶ver sin egen agent med egne tools og scaffolding.

**Hvad vi opdagede:**

<img src="images/anthropic-code-is-the-universal-interface.png" alt="Code is the universal interface" width="600" style="max-width: 100%;">

Kode er ikke bare en use case ‚Äì det er den universelle gr√¶nseflade til den digitale verden.

En coding agent kan:
- Kalde API'er for at hente data (research)
- Organisere data i filsystemet (dokumenter)
- Analysere med Python (finans)
- Generere output i ethvert format (marketing)

**Konklusion**: Vi beh√∏ver ikke mange forskellige agents ‚Äì vi beh√∏ver √âN general-purpose coding agent + **skills** der giver dom√¶neekspertise.

## Teori: Hvorfor Skills?

**Problemet:** Giv en model 100 tools, og den bliver forvirret. Tool selection degraderer.

**L√∏sningen:** Skills = "lazy-loaded expertise"
- En "router" klassificerer f√∏rst brugerens intent
- Kun relevante tools/knowledge indl√¶ses
- Modellen fokuserer p√• √©n opgave ad gangen

**Key insight:** Copilot har allerede loopet, LLM, og basale tools. Du tilf√∏jer dom√¶neviden!

#!markdown

## 4.1 GitHub Copilot Agent Mode

VS Code 1.108+ har eksperimentel support for "agent skills".

### Aktivering

1. √Öbn VS Code Settings (Ctrl+,)
2. S√∏g efter `chat.useAgentSkills`
3. Aktiver indstillingen

### Skill Struktur

```
.github/skills/
‚îî‚îÄ‚îÄ ev-charging-advisor/
    ‚îî‚îÄ‚îÄ SKILL.md
```

Copilot scanner automatisk `.github/skills/` og indl√¶ser relevante skills.

#!markdown

## 4.2 SKILL.md Anatomi

```yaml
---
name: my-skill
description: Kort beskrivelse til discovery
triggers:
  - "n√•r bruger sp√∏rger om X"
  - "n√•r der er behov for Y"
---

# Detaljerede Instruktioner

Her kommer den fulde dom√¶neviden...
```

- **YAML frontmatter:** Metadata til skill discovery
- **Markdown body:** Instruktioner, eksempler, context

#!markdown

## 4.3 √òvelse: Opret EV Charging Advisor Skill

### Step 1: Opret skill mappe

**PowerShell:**
```powershell
New-Item -ItemType Directory -Force -Path ".github/skills/ev-charging-advisor"
```

**Bash:**
```bash
mkdir -p .github/skills/ev-charging-advisor
```

### Step 2: Opret SKILL.md

Opret filen `.github/skills/ev-charging-advisor/SKILL.md`:

```yaml
---
name: ev-charging-advisor
description: Ekspertr√•dgivning om optimering af elbil-ladning p√• ChargeSmart netv√¶rket
triggers:
  - "n√•r bruger sp√∏rger om ladepris"
  - "n√•r bruger vil finde billigste ladetidspunkt"
  - "n√•r bruger sp√∏rger om batteri-tips"
  - "n√•r bruger n√¶vner ChargeSmart eller elbil-ladning"
---

# EV Charging Advisor

Du er en ekspert i at optimere elbil-ladning p√• ChargeSmart netv√¶rket i K√∏benhavn.

## ChargeSmart Tarif-struktur

| Periode | Tid | Pris/kWh |
|---------|-----|----------|
| Off-peak | 00:00-06:00 | 1.50 DKK |
| Normal | 06:00-17:00, 21:00-00:00 | 2.50 DKK |
| Peak | 17:00-21:00 | 4.00 DKK |

## Stationer i Netv√¶rket

- CPH-001: N√∏rreport Station - 150kW ultra-fast
- CPH-002: Fisketorvet Parking - 50kW fast
- CPH-003: Tivoli Garage - 50kW fast
- CPH-004: √òrestad Center - 150kW ultra-fast
- CPH-005: Amager Strandpark - 22kW slow
- CPH-006: N√∏rrebro Runddel - 50kW fast
- CPH-007: Frederiksberg Have - 7kW slow
- CPH-008: Kastrup Lufthavn P4 - 150kW ultra-fast
- CPH-009: Valby Langgade - 22kW slow
- CPH-010: Hellerup Station - 50kW fast

## Instruktioner

N√•r bruger sp√∏rger om ladning:

1. **Identificer behov** - Hvor mange kWh skal de lade?
2. **Tjek tidspunkt** - Hvorn√•r vil de lade?
3. **Beregn pris** - Brug tarif-tabellen
4. **Optimer** - Foresl√• ALTID billigere alternativer
5. **Batteri-tips** - Tilf√∏j relevante tips

## Batteri-tips

- Undg√• at lade til 100% dagligt (80% er optimalt for battery health)
- Undg√• at k√∏re under 20% regelm√¶ssigt
- Forvarm batteri i koldt vejr f√∏r hurtigladning
- Ultra-fast ladning (150kW) slider mere p√• batteriet end langsom ladning

## Eksempel-dialog

**Bruger:** Hvad koster det at lade 40 kWh kl. 18?

**Svar:** At lade 40 kWh kl. 18:00 koster **160 DKK** (peak-tarif: 4.00 DKK/kWh).

üí° **Tip:** Hvis du kan vente til kl. 21:00, falder prisen til **100 DKK** (normal-tarif).
Eller endnu bedre - lad natten over (kl. 00-06) for kun **60 DKK**!

üîã **Batteri-tip:** Hvis du ikke beh√∏ver fuld opladning, s√• lad kun til 80% for at forl√¶nge batteriets levetid.
```

#!markdown

### Step 3: Test med Copilot Chat

1. √Öbn **Copilot Chat** i VS Code (Ctrl+Alt+I)
2. Pr√∏v disse prompts:
   - "Hvad koster det at lade 50 kWh kl. 18?"
   - "Find den billigste tid at lade min elbil"
   - "Giv mig tips til at forl√¶nge mit EV batteri"

Copilot burde nu bruge din skill til at give ChargeSmart-specifikke svar! (Det er tilf√¶lded hvis du ser beskeden "Read SKILL.md file".)

#!markdown

## Checkpoint Del 4

Du har nu:
1. ‚úÖ Forst√•et Skills som "lazy-loaded expertise"
2. ‚úÖ Oprettet en SKILL.md med dom√¶neviden
3. ‚úÖ Udvidet GitHub Copilot med ChargeSmart ekspertise

**N√∏gleindsigt:** Du beh√∏ver ikke bygge en agent - du kan udvide √©n du allerede har!

---

#!markdown

# Afrunding
*10 minutter*

## To Separate Veje - Recap

### Vej A: Byg Din Egen Agent (Del 1-3)

```
SimpleTool ‚Üí OllamaSharp.Tool ‚Üí MCP Server
```

- Samme funktionalitet, stigende abstraktion
- Fuld kontrol, fuld forst√•else
- **Brug n√•r:** Custom agents, embedded systems, specifikke workflows

### Vej B: Udvid en Eksisterende Agent (Del 4)

```
GitHub Copilot + SKILL.md ‚Üí Dom√¶neviden
```

- Byg ikke infrastruktur - tilf√∏j viden
- **Brug n√•r:** Produktivitet, team workflows, quick wins

## Key Takeaways

1. **Agents er simple** - ~200 linjer loop kode
2. **"Magien" er i LLM'en** - ikke infrastrukturen
3. **MCP standardiserer** - USB-C for AI tools
4. **Skills tilf√∏jer viden** - uden at genopbygge

## N√¶ste Skridt: Enterprise Agent SDK'er

Nu hvor du har bygget din egen agent-loop og forst√•r abstraktionerne, kan du udforske etablerede SDK'er. Disse giver dig **observability**, **multi-agent orchestration** og **enterprise compliance** ud af boksen ‚Äì men bygger p√• pr√¶cis de samme principper, du har l√¶rt i dag.

**To tilgange dominerer:**

| | **Anthropic Claude Agent SDK** | **Microsoft Agent Framework** |
|---|---|---|
| **Filosofi** | "Giv Claude en computer" | "Unified multi-agent orchestration" |
| **Kerne** | Bash/fil-tools, subagents, MCP | AutoGen + Semantic Kernel |
| **Sprog** | Python | Python, C#, Java |
| **Styrke** | Simpel agent ‚Üí computer-interaktion | Enterprise: observability, compliance, A2A |
| **MCP** | ‚úÖ Native integration | ‚úÖ Native integration |

![Agent SDK Landscape](images/agent-sdk-landscape.svg)

> **N√∏gleindsigt:** Begge SDK'er bygger p√• de samme principper, du har l√¶rt (tools, loops, MCP). Forskellen ligger i *hvor meget* infrastruktur du f√•r "gratis" ‚Äì og *hvilken leverand√∏r* du binder dig til.

## The Emperor Has No Clothes

> **"The core of these tools isn't magic. It's about 200 lines of straightforward Python."**
> ‚Äî Mihail Eric

Du har nu set det selv. Du kan bygge en agent. Du forst√•r hvad der sker.

**Hvorfor er dette vigtigt?**

> Whilst software development/programming is now dead. We however deeply need software engineers with these skills who understand that LLMs are a new form of programmable computer. If you haven‚Äôt built your own coding agent yet - please do.
> ‚Äî [Geoffrey Huntley](https://ghuntley.com/loop/)


## Ressourcer

- [MCP Documentation](https://modelcontextprotocol.io)
- [Microsoft.Extensions.AI](https://github.com/dotnet/extensions)
- [GitHub Copilot Skills](https://docs.github.com/en/copilot)
- [The Emperor Has No Clothes](https://www.mihaileric.com/The-Emperor-Has-No-Clothes/)
- [OllamaSharp](https://github.com/awaescher/OllamaSharp)
- [Building agents with the Claude Agent SDK](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk)
- [Introducing Microsoft Agent Framework](https://azure.microsoft.com/en-us/blog/introducing-microsoft-agent-framework/)

---

## Tak for i dag! üéâ
