#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

# Agents, MCP & Skills

En praktisk workshop hvor vi udforsker den nye verden af **agentic software engineering**.

---

## Agenda (ca. 3,5 timer)

| Tid | Emne |
|-----|------|
| 5 min | Opsummering fra sidste gang |
| 5 min | Intro til Polyglot Notebooks |
| 15 min | Det agentiske landskab â€“ overblik |
| 55 min | **Byg en Agent** â€“ teori + Ã¸velse |
| 15 min | *Pause* |
| 50 min | MCP-servere â€“ teori + Ã¸velse |
| 45 min | Skills â€“ teori + Ã¸velse |
| 25 min | Integration â€“ sÃ¦t det hele sammen â€“ teori + Ã¸velse |
| 5 min | Afrunding |

---

#!markdown

# Opsummering fra sidste gang
*5 minutter*

<!-- TODO: Martin udfylder dette afsnit med recap fra forrige session -->

- LLMs & Agents - What are they, and why can they code? â€” Martin
- Agentisk softwareudvikling for personlig produktivitet - Emil
- Agentisk Software Engineering for fuld SDLC af et produkt - Magnus

Lige denne planche fra er meget relevant mht. dagens seance: [How LLMs Learn: The Three Stages](https://martinrl.github.io/presentations/what-are-llms-and-agents/index.html#14)

<img src="images/LLMs-14.png" alt="LLMs-14" width="600" style="max-width: 100%;">

---

#!markdown

# Intro til Polyglot Notebooks
*5 minutter*

## Hvad er en Polyglot Notebook?

- `.dib` format (tidligere `.dotnet-interactive`)
- KÃ¸rer pÃ¥ .NET Interactive kernel
- UnderstÃ¸tter flere sprog: C#, F#, HTML, Mermaid, PowerShell, JavaScript, SQL, KQL
- Celle-typer:
  - `#!markdown` - Dokumentation (som denne celle)
  - `#!csharp` - C# kode
  - `#!meta` - Kernel konfiguration
  - â€¦

## SÃ¥dan kÃ¸rer du en celle

- **Shift+Enter** - KÃ¸r celle og gÃ¥ til nÃ¦ste
- **Ctrl+Enter** - KÃ¸r celle og bliv
- Variabler persisterer pÃ¥ tvÃ¦rs af celler

#!markdown

### Mini-Ã¸velse: Hello EV World

KÃ¸r cellen nedenfor med **Shift+Enter**:

#!csharp

Console.WriteLine("Hello EV World! âš¡ğŸš—");

#!markdown

Deklarer nu en variabel:

#!csharp

var chargerName = "ChargeSmart Station Alpha";
var powerOutput = 150; // kW

#!markdown

Og brug den i nÃ¦ste celle:

#!csharp

Console.WriteLine($"{chargerName} leverer {powerOutput} kW");

#!markdown

**Checkpoint:** Du skulle se output fra alle tre celler. Variablerne `chargerName` og `powerOutput` er nu tilgÃ¦ngelige i hele notebook-sessionen.

---

#!markdown

# Det agentiske landskab â€“ overblik
*15 minutter*

<img src="images/Orloff-1600x1067.webp" alt="Professor Orloff" width="600" style="max-width: 100%;">

> An LLM is just a brain in a jar. ğŸ§ 

â€” [Simon Maple](https://www.linkedin.com/in/simonmaple/), Head of Developer Relations @ Tessl ([AI Native podcast](https://open.spotify.com/episode/1HYcUlgkCa9VwvVfuy3fyx?nd=1&dlsi=a77f69fabf8b46b1))
<br>


> *"Vi er forbi kodegenerering som flaskehalsen. Udfordringen nu er klarhed og tillid."*

> De fleste tech. startups er AI-native med < 10% af skreven af LLM'er. Store virksomheder tester stadig med PoC-projekter.

â€” [Tariq Shaukat](https://www.linkedin.com/in/tariq-shaukat/), CEO @ Sonar ([McKinsey Interview](https://www.mckinsey.com/capabilities/mckinsey-technology/our-insights/how-ai-is-shaking-up-coding-interview-with-sonar-ceo-tariq-shaukat))

## Hvorfor kan LLM'er kode sÃ¥ godt nu?

**Kode har indbygget feedback.** Til forskel fra "god tekst" kan vi objektivt mÃ¥le om kode virker:
- Kompilerer det? âœ“/âœ—
- BestÃ¥r tests? âœ“/âœ—
- LÃ¸ser det opgaven? âœ“/âœ—

Dette muliggÃ¸r **RLVR** (Reinforcement Learning with Verifiable Rewards):

<img src="images/ai-training-loop.svg" alt="AI TrÃ¦ningsloop" width="600" style="max-width: 100%;">

**Resultat:** "Extended thinking" â€” modeller der tÃ¦nker fÃ¸r de svarer (o1, o3, Claude thinking mode)

## Hvordan mÃ¥ler vi AI-agenter/LLM'er iht. kodning? (pr. 9. januar 2026)

Tre nÃ¸gle-benchmarks viser hvor langt vi er kommet:

### 1. SWE-bench: LÃ¸s rigtige GitHub issues

**SWE-bench Verified** (500 human-validerede issues):

| # | Model | Score |
|---|-------|-------|
| 1 | Claude Opus 4.5 | 80.9% |
| 2 | GPT-5.2 | 75.4% |
| 3 | Claude Opus 4.1 | 74.5% |

**SWE-bench Pro** (1865 svÃ¦rere issues, nye repos):

| # | Agent | Score |
|---|-------|-------|
| 1 | Claude Opus 4.5 | 45.9% |
| 2 | Claude Sonnet 4.5 | 43.6% |
| 3 | Gemini 3 Pro Preview | 43.3% |

[swebench.com](https://www.swebench.com/)

---

### 2. METR: Hvor lang tid kan AI arbejde selvstÃ¦ndigt?

METR mÃ¥ler **tidshorisonten** - hvor lange opgaver kan AI lÃ¸se med 50% succes?

| # | Model | 50% Tidshorisont |
|---|-------|------------------|
| 1 | Claude Opus 4.5 | ~4.8 timer |
| 2 | GPT-5.1 Codex Max | ~2.9 timer |
| 3 | GPT-5 | ~2.3 timer |

<br><img src="images/metr-timeline.svg" alt="METR Tidslinje" width="600" style="max-width: 100%;">

**NÃ¸gletal:**
- Tidshorisonten **fordobles hver 7. mÃ¥ned** (konsistent over 6 Ã¥r)
- <10% succes pÃ¥ opgaver >4 timer (men Opus 4.5 nÃ¦rmer sig!)

**Hvis trenden fortsÃ¦tter:**
- 2-4 Ã¥r: ugelange opgaver
- Ã…rtiet ud: mÃ¥nedlange projekter

[metr.org](https://metr.org/blog/2025-03-19-measuring-ai-ability-to-complete-long-tasks/)

---

### 3. DPAI Arena: Full developer workflow

JetBrains' benchmark - evaluerer hele engineering lifecycle pÃ¥ Spring-projekter (140+ opgaver).

| # | Agent | Model | Score |
|---|-------|-------|-------|
| 1 | Junie CLI 533.2 | Claude Opus 4.5 | 68.9 |
| 2 | Claude Code 2.0.55 | Claude Opus 4.5 | 68.0 |
| 3 | Junie CLI 496.3-prototype | Claude Sonnet 4.5 | 68.0 |

*BemÃ¦rk: Alle top 3 bruger Claude-modeller!*

[dpaia.dev](https://dpaia.dev/)

---

### Men pas pÃ¥: Benchmark â‰  virkelighed

METR-studie (juli 2025):
- Erfarne udviklere *troede* de var **20% hurtigere** med AI, nÃ¥r objektive tests viste de var **19% langsommere**

SikkerhedssÃ¥rbarheder ([Stanford/Boneh 2023](https://arxiv.org/abs/2211.03622)):
- Mennesker uden AI: **~50%** sÃ¥rbar kode
- Mennesker MED AI: **~64%** â€” faktisk *vÃ¦rre*!

#!markdown

## Agentarkitekturen: "It's that simple"

<img src="agent-pattern.png" alt="Agent Pattern" width="600" style="max-width: 100%;">

---

#!markdown

# Byg en Agent â€“ teori + Ã¸velse
*55 minutter (15 min teori + 40 min Ã¸velse)*

## Teori: The Emperor Has No Clothes

### Demystificering af AI Agents

> **"The LLM never actually touches your filesystem. It just *asks* for things to happen."**
> â€” Mihail Eric, ["The Emperor Has No Clothes"](https://www.mihaileric.com/The-Emperor-Has-No-Clothes/)

AI coding assistants virker som magi, men kernen er simpel:
- **~200 linjer kode** er alt der skal til
- LLM beslutter hvad der skal ske
- **Din kode** udfÃ¸rer handlingerne lokalt
- Resultater sendes tilbage til LLM

### The Agentic Loop - 5 Steps

```
1. User sender besked
2. LLM beslutter hvad der skal ske
3. Hvis LLM vil bruge et tool â†’ vi udfÃ¸rer det lokalt
4. Resultat sendes tilbage til LLM
5. Gentag indtil LLM er fÃ¦rdig (ingen tool calls)
```

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AGENTIC LOOP                       â”‚
â”‚                                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  User   â”‚â”€â”€â”€â–ºâ”‚   LLM   â”‚â”€â”€â”€â–ºâ”‚ Tool Call?   â”‚    â”‚
â”‚   â”‚ Prompt  â”‚    â”‚         â”‚    â”‚              â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                       â–²                 â”‚            â”‚
â”‚                       â”‚            Yes  â”‚  No        â”‚
â”‚                       â”‚                 â–¼            â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                  â”‚ Append  â”‚â—„â”€â”€â”€â”€â”€â”‚ Execute  â”‚      â”‚
â”‚                  â”‚ Result  â”‚      â”‚  Tool    â”‚      â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                         â”‚            â”‚
â”‚                                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”      â”‚
â”‚                                    â”‚  Done   â”‚      â”‚
â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Minimum Viable Tools

For en fungerende coding agent behÃ¸ves kun:
- **create_file** - Opret filer
- (Valgfrit: read_file, list_files)

Det er *virkelig* sÃ¥ simpelt!

#!markdown

## Ã˜velse: Byg en Agent der Skaber Kode
*40 minutter*

### MÃ¥l

Byg en agent med Ã©t tool (`create_file`) der kan generere C# kode.

**Forventet output:** Agenten skaber `HelloAgentWorld.cs` i workshop-mappen!

#!markdown

### Step 1: Installer Ollama (forudsÃ¦tning)

Hvis ikke allerede gjort:
```powershell
winget install Ollama.Ollama
ollama pull llama3.1:8b
ollama list  # Verificer installation
```

#!csharp

// Test: Kan vi nÃ¥ Ollama?
using System.Net.Http;

var httpClient = new HttpClient();
try
{
    var response = await httpClient.GetStringAsync("http://localhost:11434/api/tags");
    Console.WriteLine("âœ… Ollama kÃ¸rer!");
}
catch (Exception ex)
{
    Console.WriteLine($"âŒ Ollama kÃ¸rer IKKE: {ex.Message}");
    Console.WriteLine("Start Ollama med: ollama serve");
}

#!markdown

### Step 2: Installer OllamaSharp

#!csharp

#r "nuget: OllamaSharp, 5.1.3"

using OllamaSharp;
using OllamaSharp.Models;
using OllamaSharp.Models.Chat;
using System.Text.Json;

Console.WriteLine("âœ… OllamaSharp loaded!");

#!markdown

### Step 3: Definer `create_file` Tool

#!csharp

// Tool definition - dette fortÃ¦ller LLM hvad den kan gÃ¸re
var createFileTool = new Tool
{
    Type = "function",
    Function = new Function
    {
        Name = "create_file",
        Description = "Create a file with the given content. Use this when asked to create, write, or generate a file.",
        Parameters = new Parameters
        {
            Type = "object",
            Properties = new Dictionary<string, Property>
            {
                ["path"] = new Property
                {
                    Type = "string",
                    Description = "The file name to create (e.g., 'HelloWorld.cs')"
                },
                ["content"] = new Property
                {
                    Type = "string",
                    Description = "The content to write to the file"
                }
            },
            Required = ["path", "content"]
        }
    }
};

Console.WriteLine("âœ… Tool defineret:");
Console.WriteLine($"   Name: {createFileTool.Function.Name}");
Console.WriteLine($"   Description: {createFileTool.Function.Description}");

#!markdown

### Step 4: Tool Execution Function

**Din opgave:** Implementer funktionen der faktisk opretter filen.

#!csharp

// Workshop folder path
var workshopPath = @"C:\code\GitHub\agentic-swe-workshops";

string ExecuteCreateFile(string path, string content)
{
    // TODO: Implementer fil-oprettelse
    // 1. Kombiner workshopPath med path
    // 2. Skriv content til filen
    // 3. Returner success/error besked

    throw new NotImplementedException("Implementer ExecuteCreateFile!");
}

#!markdown

### LÃ¸sning Step 4

<details>
<summary>Klik for at se lÃ¸sningen</summary>

```csharp
string ExecuteCreateFile(string path, string content)
{
    var fullPath = Path.Combine(workshopPath, path);

    try
    {
        File.WriteAllText(fullPath, content);
        return $"âœ… File created successfully at: {fullPath}";
    }
    catch (Exception ex)
    {
        return $"âŒ Error creating file: {ex.Message}";
    }
}
```

</details>

#!markdown

### Step 5: Implementer The Agentic Loop

**Din opgave:** Udfyld TODO-sektionerne i loopet.

#!csharp

async Task<string> RunAgent(string userMessage)
{
    var client = new OllamaApiClient("http://localhost:11434");

    var messages = new List<Message>
    {
        new Message
        {
            Role = ChatRole.System,
            Content = """
                You are a helpful coding assistant. When asked to create files,
                you MUST use the create_file tool. Always respond in the same
                language as the user's message.
                """
        },
        new Message { Role = ChatRole.User, Content = userMessage }
    };

    var tools = new List<Tool> { createFileTool };
    var maxIterations = 10;
    var iteration = 0;

    while (iteration < maxIterations)
    {
        iteration++;
        Console.WriteLine($"\n--- Iteration {iteration} ---");

        // Send to LLM
        var request = new ChatRequest
        {
            Model = "llama3.1:8b",
            Messages = messages,
            Tools = tools,
            Stream = false
        };

        var response = await client.ChatAsync(request);
        var assistantMessage = response.Message;
        messages.Add(assistantMessage);

        // TODO: Tjek om response indeholder tool calls
        // Hint: assistantMessage.ToolCalls er en liste af tool calls

        if (assistantMessage.ToolCalls != null && assistantMessage.ToolCalls.Any())
        {
            Console.WriteLine($"LLM wants to call {assistantMessage.ToolCalls.Count()} tool(s)");

            foreach (var toolCall in assistantMessage.ToolCalls)
            {
                Console.WriteLine($"  Tool: {toolCall.Function.Name}");

                // TODO: Eksekver tool og tilfÃ¸j resultat
                // 1. Hent path og content fra toolCall.Function.Arguments
                // 2. Kald ExecuteCreateFile(path, content)
                // 3. TilfÃ¸j tool result som ny Message med Role = ChatRole.Tool

                throw new NotImplementedException("Implementer tool execution!");
            }
        }
        else
        {
            // Ingen tool calls - LLM er fÃ¦rdig
            Console.WriteLine("LLM finished (no tool calls)");
            return assistantMessage.Content ?? "No response";
        }
    }

    return "Max iterations reached";
}

Console.WriteLine("âœ… Agentic loop function defined!");

#!markdown

### LÃ¸sning Step 5

<details>
<summary>Klik for at se lÃ¸sningen</summary>

```csharp
if (assistantMessage.ToolCalls != null && assistantMessage.ToolCalls.Any())
{
    Console.WriteLine($"LLM wants to call {assistantMessage.ToolCalls.Count()} tool(s)");

    foreach (var toolCall in assistantMessage.ToolCalls)
    {
        Console.WriteLine($"  Tool: {toolCall.Function.Name}");
        Console.WriteLine($"  Args: {JsonSerializer.Serialize(toolCall.Function.Arguments)}");

        string toolResult;
        if (toolCall.Function.Name == "create_file")
        {
            var args = toolCall.Function.Arguments;
            var path = args["path"]?.ToString() ?? "unknown.txt";
            var content = args["content"]?.ToString() ?? "";
            toolResult = ExecuteCreateFile(path, content);
        }
        else
        {
            toolResult = $"Unknown tool: {toolCall.Function.Name}";
        }

        Console.WriteLine($"  Result: {toolResult}");

        messages.Add(new Message
        {
            Role = ChatRole.Tool,
            Content = toolResult
        });
    }
}
```

</details>

#!markdown

### Step 6: Test din Agent! ğŸš€

#!csharp

var result = await RunAgent(
    "Lav en C# fil der hedder 'HelloAgentWorld.cs' som printer 'Hello Agent World!' til konsollen."
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result);

#!markdown

### Step 7: Verificer at filen blev oprettet

#!csharp

var filePath = Path.Combine(workshopPath, "HelloAgentWorld.cs");

if (File.Exists(filePath))
{
    Console.WriteLine("ğŸ‰ SUCCESS! File created:");
    Console.WriteLine(new string('-', 40));
    Console.WriteLine(File.ReadAllText(filePath));
    Console.WriteLine(new string('-', 40));
}
else
{
    Console.WriteLine("âŒ File was NOT created. Check the agent output above.");
}

#!markdown

### Checkpoint

Du har nu:
1. âœ… Defineret et tool (`create_file`)
2. âœ… Implementeret tool execution
3. âœ… Bygget et agentic loop (~50 linjer!)
4. âœ… Set agenten skabe reel kode

**NÃ¸gleindsigt:** Det er *virkelig* sÃ¥ simpelt. ~200 linjer kode, og du har en fungerende agent!

---

# â˜• PAUSE (15 min)

---

#!markdown

# MCP-servere â€“ teori + Ã¸velse
*50 minutter (15 min teori + 35 min Ã¸velse)*

> **Fra Agent-Ã¸velsen:** Vi byggede Ã©t simpelt tool (`create_file`) manuelt.
> Nu skal vi se hvordan **MCP standardiserer tools** - og introducerer vores ChargeSmart domÃ¦ne!

## Teori: Model Context Protocol

### Hvad lÃ¸ser MCP?

**Problemet:** Hver LLM-integration krÃ¦ver custom connectors

<img src="images/mcp-problem.svg" alt="MCP Problem" width="600" style="max-width: 100%;">

**LÃ¸sningen:** Ã‰n standardprotokol

<img src="images/mcp-solution.svg" alt="MCP Solution" width="600" style="max-width: 100%;">

### Protokol Basics

- **JSON-RPC 2.0** - Request/response format
- **Transport:** stdio (lokalt) eller SSE (remote)
- **Server anatomi:**
  - **Tools** - Funktioner LLM kan kalde
  - **Resources** - Data LLM kan lÃ¦se
  - **Prompts** - Foruddefinerede prompt templates

### C# SDK

```csharp
// NuGet: ModelContextProtocol
[McpServerToolType]
public static class MyTools
{
    [McpServerTool, Description("Beskrivelse til LLM")]
    public static string MyTool(string param) => "result";
}
```

#!markdown

## Ã˜velse 1: Byg en EV Charger Status Server
*35 minutter*

### MÃ¥l
Byg en MCP server med Ã©t tool: `GetChargerStatus(chargerId)`

### DomÃ¦ne: ChargeSmart Network

Vi arbejder med et fiktivt EV-ladenetvÃ¦rk:
- 10 ladestationer i KÃ¸benhavn
- Mix af slow (7kW), fast (50kW), ultra-fast (150kW)
- Real-time tilgÃ¦ngelighed

#!markdown

### Step 1: Installer NuGet pakker

#!csharp

#r "nuget: ModelContextProtocol, 0.1.0-preview.15"
#r "nuget: Microsoft.Extensions.Hosting, 8.0.0"

#!markdown

### Step 2: Definer data modeller

#!csharp

public record ChargerInfo(
    string Id,
    string Name,
    string Location,
    int PowerKw,
    string Type // "slow", "fast", "ultra-fast"
);

public record ChargerStatus(
    string ChargerId,
    bool Available,
    int PowerKw,
    string CurrentSession, // null hvis ledig
    DateTime? SessionStart,
    double? EnergyDeliveredKwh
);

#!markdown

### Step 3: Mock data for vores ladenetvÃ¦rk

#!csharp

var chargers = new Dictionary<string, ChargerInfo>
{
    ["CPH-001"] = new("CPH-001", "NÃ¸rreport Station", "NÃ¸rreport", 150, "ultra-fast"),
    ["CPH-002"] = new("CPH-002", "Fisketorvet Parking", "Fisketorvet", 50, "fast"),
    ["CPH-003"] = new("CPH-003", "Tivoli Garage", "Tivoli", 50, "fast"),
    ["CPH-004"] = new("CPH-004", "Ã˜restad Center", "Ã˜restad", 150, "ultra-fast"),
    ["CPH-005"] = new("CPH-005", "Amager Strandpark", "Amager", 22, "slow"),
    ["CPH-006"] = new("CPH-006", "NÃ¸rrebro Runddel", "NÃ¸rrebro", 50, "fast"),
    ["CPH-007"] = new("CPH-007", "Frederiksberg Have", "Frederiksberg", 7, "slow"),
    ["CPH-008"] = new("CPH-008", "Kastrup Lufthavn P4", "Kastrup", 150, "ultra-fast"),
    ["CPH-009"] = new("CPH-009", "Valby Langgade", "Valby", 22, "slow"),
    ["CPH-010"] = new("CPH-010", "Hellerup Station", "Hellerup", 50, "fast"),
};

// Simuler aktive sessioner (nogle ladere er optaget)
var activeSessions = new Dictionary<string, (string vehicleId, DateTime start, double kwh)>
{
    ["CPH-002"] = ("EV-Tesla-3", DateTime.Now.AddMinutes(-45), 28.5),
    ["CPH-004"] = ("EV-Polestar-2", DateTime.Now.AddMinutes(-12), 18.2),
    ["CPH-007"] = ("EV-VW-ID4", DateTime.Now.AddHours(-2), 11.0),
};

Console.WriteLine($"Loaded {chargers.Count} chargers, {activeSessions.Count} active sessions");

#!markdown

### Step 4: Implementer MCP Tool

**Din opgave:** Udfyld `GetChargerStatus` metoden nedenfor.

Metoden skal:
1. SlÃ¥ charger op i `chargers` dictionary
2. Tjekke om der er en aktiv session i `activeSessions`
3. Returnere en `ChargerStatus` med alle felter udfyldt

#!csharp

using System.ComponentModel;
using ModelContextProtocol.Server;

[McpServerToolType]
public static class ChargerTools
{
    // Reference til vores data (i produktion ville dette vÃ¦re en service)
    public static Dictionary<string, ChargerInfo> Chargers { get; set; }
    public static Dictionary<string, (string vehicleId, DateTime start, double kwh)> ActiveSessions { get; set; }

    [McpServerTool]
    [Description("Get real-time status of an EV charger including availability and current session info")]
    public static ChargerStatus GetChargerStatus(
        [Description("The charger ID, e.g. CPH-001")] string chargerId)
    {
        // TODO: Implementer denne metode
        // 1. Find charger i Chargers dictionary
        // 2. Tjek om chargerId findes i ActiveSessions
        // 3. Returner ChargerStatus med korrekte vÃ¦rdier

        throw new NotImplementedException("Implementer GetChargerStatus!");
    }
}

// Initialiser tool med vores data
ChargerTools.Chargers = chargers;
ChargerTools.ActiveSessions = activeSessions;

#!markdown

### Step 5: Test dit tool

NÃ¥r du har implementeret `GetChargerStatus`, kÃ¸r disse tests:

#!csharp

// Test 1: Ledig lader
var status1 = ChargerTools.GetChargerStatus("CPH-001");
Console.WriteLine($"CPH-001: Available={status1.Available}, Power={status1.PowerKw}kW");

// Test 2: Optaget lader
var status2 = ChargerTools.GetChargerStatus("CPH-002");
Console.WriteLine($"CPH-002: Available={status2.Available}, Session={status2.CurrentSession}, Energy={status2.EnergyDeliveredKwh}kWh");

// Test 3: Ukendt lader
try
{
    var status3 = ChargerTools.GetChargerStatus("UNKNOWN");
    Console.WriteLine("Fejl: Burde have kastet exception!");
}
catch (Exception ex)
{
    Console.WriteLine($"Korrekt! Exception: {ex.Message}");
}

#!markdown

### LÃ¸sning (fold ud hvis du sidder fast)

<details>
<summary>Klik for at se lÃ¸sningen</summary>

```csharp
[McpServerTool]
[Description("Get real-time status of an EV charger including availability and current session info")]
public static ChargerStatus GetChargerStatus(
    [Description("The charger ID, e.g. CPH-001")] string chargerId)
{
    if (!Chargers.TryGetValue(chargerId, out var charger))
    {
        throw new ArgumentException($"Unknown charger: {chargerId}");
    }

    var hasSession = ActiveSessions.TryGetValue(chargerId, out var session);

    return new ChargerStatus(
        ChargerId: chargerId,
        Available: !hasSession,
        PowerKw: charger.PowerKw,
        CurrentSession: hasSession ? session.vehicleId : null,
        SessionStart: hasSession ? session.start : null,
        EnergyDeliveredKwh: hasSession ? session.kwh : null
    );
}
```

</details>

#!markdown

### Checkpoint

Du skulle se output lignende:
```
CPH-001: Available=True, Power=150kW
CPH-002: Available=False, Session=EV-Tesla-3, Energy=28.5kWh
Korrekt! Exception: Unknown charger: UNKNOWN
```

---

#!markdown

# Skills â€“ teori + Ã¸velse
*45 minutter (10 min teori + 35 min Ã¸velse)*

## Teori: Agent Skills

### NÃ¸gleindsigt fra Anthropic

> **"Stop building agents, start building skills"**

Hvorfor?
- Agents er komplekse at bygge og vedligeholde
- Skills er genanvendelige pÃ¥ tvÃ¦rs af alle agents
- MCP standardiserer tool-connectivity
- Fokuser pÃ¥ **domÃ¦neviden**, ikke infrastruktur

### Hvad er en Skill?

En **skill** er en mappe med struktureret viden som en AI-agent kan bruge:

```
my-skill/
â”œâ”€â”€ SKILL.md           # Hovedinstruktioner (YAML frontmatter + markdown)
â”œâ”€â”€ scripts/           # Eksekverbare scripts agenten kan kÃ¸re
â”‚   â””â”€â”€ helper.csx
â””â”€â”€ references/        # Ekstra dokumentation
    â””â”€â”€ guide.md
```

### Hvorfor Skills?

- **Genanvendelige** - Virker i bÃ¥de GitHub Copilot OG Claude Code
- **Progressive disclosure** - Metadata fÃ¸rst, detaljer on-demand
- **Versionerbare** - Git-venlige tekstfiler
- **Testbare** - Scripts kan kÃ¸res uafhÃ¦ngigt

#!markdown

### SKILL.md Struktur

```yaml
---
name: my-skill
description: Kort beskrivelse til agent discovery
triggers:
  - "nÃ¥r bruger spÃ¸rger om X"
  - "nÃ¥r der er behov for Y"
---

# Detaljerede Instruktioner

Her kommer de fulde instruktioner agenten skal fÃ¸lge...
```

### Installation

**GitHub Copilot:**
```json
// .vscode/settings.json
{
  "github.copilot.chat.codeGeneration.instructions": [
    { "file": "skills/my-skill/SKILL.md" }
  ]
}
```

**Claude Code:**
```bash
# Automatisk hvis SKILL.md er i repo
# Eller via .claude/settings.json
```

#!markdown

## Ã˜velse 2: Opret en EV Charging Advisor Skill
*35 minutter*

### MÃ¥l

Byg en skill der hjÃ¦lper med:
- Anbefaling af optimal ladetid (billigste periode)
- Beregning af ladeomkostninger
- Tips til batterivedligeholdelse

### Tarif-struktur (ChargeSmart priser)

| Periode | Tid | Pris/kWh |
|---------|-----|----------|
| Off-peak | 00:00-06:00 | 1.50 DKK |
| Normal | 06:00-17:00, 21:00-00:00 | 2.50 DKK |
| Peak | 17:00-21:00 | 4.00 DKK |

#!markdown

### Step 1: Skill mappe-struktur

Opret fÃ¸lgende struktur (vi simulerer det her i notebook'en):

```
ev-charging-advisor/
â”œâ”€â”€ SKILL.md
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ calculate-cost.csx
â””â”€â”€ references/
    â””â”€â”€ tariff-guide.md
```

#!markdown

### Step 2: SKILL.md indhold

Her er skabelonen - **din opgave er at udfylde instruktionerne**:

#!csharp

var skillMd = """
---
name: ev-charging-advisor
description: Helps users optimize EV charging times and costs for ChargeSmart network
triggers:
  - "when user asks about charging costs"
  - "when user wants to find cheapest charging time"
  - "when user asks about battery health tips"
version: 1.0.0
---

# EV Charging Advisor

Du er en ekspert i at optimere elbil-ladning pÃ¥ ChargeSmart netvÃ¦rket.

## Dine Capabilities

1. **Omkostningsberegning** - Beregn pris baseret pÃ¥ kWh og tidspunkt
2. **Tidsoptimering** - Find billigste ladetidspunkt
3. **Batteri-tips** - Giv rÃ¥d om batterivedligeholdelse

## Tarif-struktur

<!-- TODO: TilfÃ¸j tarif-tabel her -->

## Instruktioner

NÃ¥r bruger spÃ¸rger om ladning:

<!-- TODO: TilfÃ¸j step-by-step instruktioner -->

## Scripts

Du har adgang til `scripts/calculate-cost.csx` til prÃ¦cise beregninger.
Kald scriptet med: `dotnet script scripts/calculate-cost.csx -- <kwh> <hour>`

""";

Console.WriteLine("SKILL.md template loaded");
Console.WriteLine(skillMd);

#!markdown

### Step 3: Implementer calculate-cost.csx

**Din opgave:** Skriv et C# script der beregner ladeomkostninger.

Input: `<kwh> <hour>` (f.eks. `50 18` = 50 kWh kl. 18:00)
Output: Total pris i DKK

#!csharp

// Simuler scriptet som en funktion her i notebook'en
decimal CalculateChargingCost(double kwh, int hour)
{
    // TODO: Implementer prisberegning baseret pÃ¥ tarif-struktur
    // Off-peak (00-06): 1.50 DKK/kWh
    // Normal (06-17, 21-00): 2.50 DKK/kWh
    // Peak (17-21): 4.00 DKK/kWh

    throw new NotImplementedException("Implementer CalculateChargingCost!");
}

#!markdown

### Step 4: Test din beregning

#!csharp

// Test cases
Console.WriteLine($"50 kWh kl. 03:00 (off-peak): {CalculateChargingCost(50, 3)} DKK");  // Forventet: 75 DKK
Console.WriteLine($"50 kWh kl. 10:00 (normal): {CalculateChargingCost(50, 10)} DKK");   // Forventet: 125 DKK
Console.WriteLine($"50 kWh kl. 18:00 (peak): {CalculateChargingCost(50, 18)} DKK");     // Forventet: 200 DKK

#!markdown

### LÃ¸sning (fold ud hvis du sidder fast)

<details>
<summary>Klik for at se lÃ¸sningen</summary>

```csharp
decimal CalculateChargingCost(double kwh, int hour)
{
    decimal pricePerKwh = hour switch
    {
        >= 0 and < 6 => 1.50m,      // Off-peak
        >= 6 and < 17 => 2.50m,     // Normal (morning/day)
        >= 17 and < 21 => 4.00m,    // Peak
        >= 21 and <= 23 => 2.50m,   // Normal (evening)
        _ => throw new ArgumentException($"Invalid hour: {hour}")
    };

    return (decimal)kwh * pricePerKwh;
}
```

</details>

#!markdown

### Step 5: FÃ¦rdiggÃ¸r SKILL.md

Opdater `skillMd` variablen med:
1. Komplet tarif-tabel
2. Step-by-step instruktioner til agenten
3. Eksempler pÃ¥ gode svar

#!csharp

// FÃ¦rdig SKILL.md
var completedSkillMd = """
---
name: ev-charging-advisor
description: Helps users optimize EV charging times and costs for ChargeSmart network
triggers:
  - "when user asks about charging costs"
  - "when user wants to find cheapest charging time"
  - "when user asks about battery health tips"
version: 1.0.0
---

# EV Charging Advisor

Du er en ekspert i at optimere elbil-ladning pÃ¥ ChargeSmart netvÃ¦rket.

## Tarif-struktur

| Periode | Tid | Pris/kWh |
|---------|-----|----------|
| Off-peak | 00:00-06:00 | 1.50 DKK |
| Normal | 06:00-17:00, 21:00-00:00 | 2.50 DKK |
| Peak | 17:00-21:00 | 4.00 DKK |

## Instruktioner

NÃ¥r bruger spÃ¸rger om ladning:

1. **Identificer behov** - Hvor mange kWh skal de lade?
2. **Tjek tidspunkt** - HvornÃ¥r vil de lade?
3. **Beregn pris** - Brug calculate-cost.csx scriptet
4. **Optimer** - ForeslÃ¥ billigere alternativer hvis relevant
5. **Batteri-tips** - TilfÃ¸j relevante tips om batterivedligeholdelse

## Batteri-tips

- UndgÃ¥ at lade til 100% dagligt (80% er optimalt)
- UndgÃ¥ at lade under 20% regelmÃ¦ssigt
- Forvarm batteri i koldt vejr fÃ¸r hurtigladning
- Ultra-fast ladning (150kW) slider mere end langsom ladning

## Eksempel-dialog

**Bruger:** Hvad koster det at lade 40 kWh kl. 18?
**Assistent:** At lade 40 kWh kl. 18:00 koster 160 DKK (peak-tarif: 4.00 DKK/kWh).

ğŸ’¡ **Tip:** Hvis du kan vente til kl. 21:00, falder prisen til 100 DKK (normal-tarif).
Eller endnu bedre - lad natten over (kl. 00-06) for kun 60 DKK!
""";

Console.WriteLine("Completed SKILL.md:");
Console.WriteLine(completedSkillMd);

#!markdown

### Checkpoint

Du har nu:
1. âœ… En SKILL.md med metadata og instruktioner
2. âœ… Et calculate-cost script
3. âœ… Klar til brug i GitHub Copilot eller Claude Code

---

#!markdown

Nu har vi alle byggeklodserne:
- **Agent** (bygget i fÃ¸rste Ã¸velse) - ForstÃ¥r loopet
- **MCP** (bygget i anden Ã¸velse) - ChargeSmart tools
- **Skills** (bygget i tredje Ã¸velse) - DomÃ¦neviden

Lad os kombinere dem!

#!markdown

# Integration â€“ sÃ¦t det hele sammen â€“ teori + Ã¸velse
*25 minutter (5 min teori + 20 min Ã¸velse)*

## Teori: Connecting the Pieces

### 2026 MÃ¸nsteret

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                            â”‚
â”‚   SKILLS provide EXPERTISE (how to use tools well)         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”‚
â”‚   "NÃ¥r bruger spÃ¸rger om ladning, beregn fÃ¸rst pris,       â”‚
â”‚    foreslÃ¥ derefter billigere alternativer..."             â”‚
â”‚                                                            â”‚
â”‚   MCP provides CONNECTIVITY (tools/data access)            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”‚
â”‚   GetChargerStatus(), SearchChargers(), etc.               â”‚
â”‚                                                            â”‚
â”‚   AGENT provides ORCHESTRATION                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚   The loop: prompt â†’ LLM â†’ tool? â†’ execute â†’ repeat        â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Thin Agent Core + Rich Skills + MCP Ecosystem

- **Agenten** er simpel: bare et loop
- **Skills** indeholder al domÃ¦neviden
- **MCP** standardiserer tool access

#!markdown

## Ã˜velse 4: Wire It All Together
*20 minutter*

### MÃ¥l

Kombiner alle tre komponenter:
1. **MCP Server** (fra Module 1) - Tool provider
2. **Skill** (fra Module 2) - DomÃ¦neviden
3. **Agent** (fra Module 3) - Orchestration

#!csharp

// Kombiner skill instructions med agent system prompt
var skillInstructions = """
    ## EV Charging Advisor Skill

    Du er en ekspert i at optimere elbil-ladning pÃ¥ ChargeSmart netvÃ¦rket.

    ### Tarif-struktur
    | Periode | Tid | Pris/kWh |
    |---------|-----|----------|
    | Off-peak | 00:00-06:00 | 1.50 DKK |
    | Normal | 06:00-17:00, 21:00-00:00 | 2.50 DKK |
    | Peak | 17:00-21:00 | 4.00 DKK |

    ### Instruktioner
    1. Identificer brugerens ladebehov (kWh, tidspunkt)
    2. SÃ¸g efter relevante ladere med search_chargers
    3. Tjek tilgÃ¦ngelighed med get_charger_status
    4. Beregn pris med calculate_charging_cost
    5. ForeslÃ¥ ALTID billigere alternativer hvis relevant
    6. TilfÃ¸j batteri-tips nÃ¥r passende

    ### Batteri-tips
    - UndgÃ¥ at lade til 100% dagligt (80% er optimalt)
    - Ultra-fast ladning (150kW) slider mere pÃ¥ batteriet
    """;

var enhancedSystemPrompt = $"""
    Du er en hjÃ¦lpsom EV-ladnings assistent for ChargeSmart netvÃ¦rket i KÃ¸benhavn.

    {skillInstructions}

    Svar altid pÃ¥ dansk. VÃ¦r venlig og informativ.
    """;

Console.WriteLine("Enhanced system prompt with skill instructions ready!");

#!csharp

// Opdateret agent med skill instructions
async Task<string> RunEnhancedAgent(string userQuery, string apiKey)
{
    var client = new AnthropicClient(apiKey);

    var messages = new List<Message>
    {
        new Message(RoleType.User, userQuery)
    };

    const int maxIterations = 10;
    var iterations = 0;

    while (iterations < maxIterations)
    {
        iterations++;
        Console.WriteLine($"\n--- Iteration {iterations} ---");

        var request = new MessageRequest
        {
            Model = "claude-sonnet-4-20250514",
            MaxTokens = 1024,
            System = enhancedSystemPrompt, // Nu med skill instructions!
            Messages = messages,
            Tools = tools
        };

        var response = await client.Messages.CreateAsync(request);
        Console.WriteLine($"Stop reason: {response.StopReason}");

        if (response.StopReason == "tool_use")
        {
            messages.Add(new Message(RoleType.Assistant, response.Content));

            var toolResults = new List<ContentBlock>();

            foreach (var content in response.Content)
            {
                if (content is ToolUseContent toolUse)
                {
                    Console.WriteLine($"Executing tool: {toolUse.Name}");
                    var result = ExecuteTool(toolUse.Name, toolUse.Input);
                    Console.WriteLine($"Result: {result.Substring(0, Math.Min(100, result.Length))}...");

                    toolResults.Add(new ToolResultContent
                    {
                        ToolUseId = toolUse.Id,
                        Content = result
                    });
                }
            }

            messages.Add(new Message(RoleType.User, toolResults));
        }
        else
        {
            var textContent = response.Content
                .OfType<TextContent>()
                .FirstOrDefault();

            return textContent?.Text ?? "Ingen respons";
        }
    }

    return "Max iterations reached";
}

Console.WriteLine("Enhanced agent ready!");

#!markdown

### End-to-End Test

#!csharp

if (!string.IsNullOrEmpty(apiKey))
{
    var queries = new[]
    {
        "Jeg skal lade min Tesla med 60 kWh. Det er kl 18 nu. Hvad er mine muligheder?",
        "Find den billigste mÃ¥de at lade 40 kWh pÃ¥ i dag",
    };

    foreach (var query in queries)
    {
        Console.WriteLine($"\n{'=',-60}");
        Console.WriteLine($"USER: {query}");
        Console.WriteLine($"{'=',-60}");

        var response = await RunEnhancedAgent(query, apiKey);
        Console.WriteLine($"\nASSISTANT:\n{response}");
    }
}

#!markdown

### Checkpoint

Den enhanced agent skulle nu:
- âœ… Bruge skill instructions til at guide sine svar
- âœ… Altid foreslÃ¥ billigere ladetidspunkter
- âœ… Inkludere batteri-tips nÃ¥r relevant
- âœ… Give komplette, venlige svar pÃ¥ dansk

---

#!markdown

# Afrunding
*5 minutter*

## Recap

| Komponent | Rolle |
|-----------|-------|
| **MCP** | Connectivity - standardiseret tool/data access |
| **Skills** | Expertise - domÃ¦neviden og procedurer |
| **Agent** | Orchestration - LLM loop med tools |

## Key Takeaways

1. **Agents er simple** - bare et loop med tool execution
2. **Skills er genanvendelige** - virker pÃ¥ tvÃ¦rs af alle agent platforms
3. **MCP standardiserer** - Ã©n protokol for alle tools
4. **Fokuser pÃ¥ domÃ¦neviden** - ikke infrastruktur

## What's Next?

- **Skill marketplaces** - Del og brug andres skills
- **MCP Apps** - Standalone MCP-baserede applikationer
- **Parallel agents** - Flere agents der samarbejder
- **Anthropic Claude Agent SDK** - Production-ready agent framework

## Resources

- [MCP Documentation](https://modelcontextprotocol.io)
- [Anthropic SDK](https://github.com/anthropics/anthropic-sdk-dotnet)
- [GitHub Copilot Skills](https://docs.github.com/en/copilot)
- [Claude Code](https://claude.ai/code)

---

## Tak for i dag! ğŸ‰

SpÃ¸rgsmÃ¥l? Kontakt: **Context&**
