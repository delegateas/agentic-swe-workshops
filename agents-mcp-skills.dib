#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

# Agents, MCP & Skills

En praktisk workshop hvor vi udforsker den nye verden af **agentic software engineering**.

---

## Agenda (ca. 3,5 timer)

| Tid | Emne | Ã˜velser |
|-----|------|---------|
| 20 min | Intro, Recap & Polyglot Notebooks | |
| 70 min | Agenter - teori og byg din egen | **Ã˜velse 1:** Tool Execute-funktioner, **Ã˜velse 2:** Human-in-the-loop |
| 15 min | Abstraktionsstigen â€“ OllamaSharp.Tool | *Valgfri* |
| 15 min | *Pause* | |
| 45 min | Abstraktionsstigen â€“ MCP | **Ã˜velse 3:** AIFunction Tools |
| 20 min | Extension: get_nearest_station | **Ã˜velse 4:** Nyt tool |
| 25 min | Skills â€“ teori og prÃ¸v med GitHub Copilot | SKILL.md |
| 10 min | Afrunding | |

---

## To Separate Veje

```
VEJ A: Byg Din Egen Agent (Del 1-3 + Extension)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Del 1: SimpleTool + Manuel Loop                             â”‚
â”‚     â†’ Ã˜velse 1: Skriv Execute-funktioner                     â”‚
â”‚     â†’ Ã˜velse 2: Human-in-the-loop bekrÃ¦ftelse                â”‚
â”‚  Del 2: OllamaSharp.Tool (valgfri sammenligning)             â”‚
â”‚  Del 3: MCP + AIFunction                                     â”‚
â”‚     â†’ Ã˜velse 3: AIFunctionFactory tools                      â”‚
â”‚  Extension: Udvid med nyt tool                               â”‚
â”‚     â†’ Ã˜velse 4: get_nearest_station                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VEJ B: Udvid en Eksisterende Agent (Del 4 - SEPARAT)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Del 4: GitHub Copilot + SKILL.md                            â”‚
â”‚     â†’ Byg ikke en agent, udvid Ã©n du allerede har            â”‚
â”‚     â†’ SKILL.md filer tilfÃ¸jer domÃ¦neviden                    â”‚
â”‚     â†’ Copilot har allerede loopet, LLM, tools                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#!markdown

# Del 0: Intro, Recap & Polyglot Notebooks
*20 minutter*

#!markdown

#### â„¹ï¸ InstallÃ©r Ollama nu, da det tager lidt tid

**Windows (PowerShell):**
```powershell
winget install Ollama.Ollama
```

**Mac (Homebrew):**
```bash
brew install ollama
```

Start Ollama og hiv modellen ned:
```bash
ollama serve
ollama pull llama3.1:8b
```

ğŸ‘†ğŸ» kan ogsÃ¥ foretages i GUI; vÃ¦lg model, skriv en prompt (f.eks. "hej") og tryk retur

## Opsummering fra sidste gang

- LLMs & Agents - What are they, and why can they code? â€” Martin
- Agentisk softwareudvikling for personlig produktivitet â€” Emil
- Agentisk Software Engineering for fuld SDLC af et produkt â€” Magnus

Lige denne planche er meget relevant mht. dagens seance: [How LLMs Learn: The Three Stages](https://martinrl.github.io/presentations/what-are-llms-and-agents/index.html#14)

<img src="images/LLMs-14.png" alt="LLMs-14" width="600" style="max-width: 100%;">

---

#!markdown

## Intro til Polyglot Notebooks

### Hvad er en Polyglot Notebook?

- `.dib` format (tidligere `.dotnet-interactive`)
- KÃ¸rer pÃ¥ .NET Interactive kernel
- UnderstÃ¸tter flere sprog: C#, F#, HTML, Mermaid, PowerShell, JavaScript, SQL, KQL

### SÃ¥dan kÃ¸rer du en celle

- **Shift+Enter** - KÃ¸r celle og gÃ¥ til nÃ¦ste
- **Ctrl+Enter** - KÃ¸r celle og bliv
- Variabler persisterer pÃ¥ tvÃ¦rs af celler

#!csharp

Console.WriteLine("Hello EV World!");

#!markdown

---

## Det Agentiske Landskab

<img src="images/Orloff-1600x1067.webp" alt="Professor Orloff" width="600" style="max-width: 100%;">
<br><br>

> An LLM is just a brain in a jar. ğŸ§ 

â€” [Simon Maple](https://www.linkedin.com/in/simonmaple/), Head of Developer Relations @ Tessl ([AI Native podcast](https://open.spotify.com/episode/1HYcUlgkCa9VwvVfuy3fyx?nd=1&dlsi=a77f69fabf8b46b1))

### Hvorfor kan LLM'er kode sÃ¥ godt nu?

**Kode har indbygget feedback.** Til forskel fra "god tekst" kan vi objektivt mÃ¥le om kode virker:
- Kompilerer det? âœ…/âŒ
- BestÃ¥r tests? âœ…/âŒ
- LÃ¸ser det opgaven? âœ…/âŒ

Dette muliggÃ¸r **RLVR** (*Reinforcement Learning with Verifiable Rewards*):

<img src="images/ai-training-loop.svg" alt="AI TrÃ¦ningsloop" width="600" style="max-width: 100%;">

#!markdown

### Benchmarks (pr. januar 2026)

#### SWE-bench: LÃ¸s rigtige GitHub issues

**SWE-bench Verified** (500 human-validerede issues):

| # | Model | Score |
|---|-------|-------|
| 1 | Claude Opus 4.5 | 80.9% |
| 2 | GPT-5.2 | 75.4% |
| 3 | Claude Opus 4.1 | 74.5% |

**SWE-bench Pro** (1865 svÃ¦rere issues, nye repos):

| # | Agent | Score |
|---|-------|-------|
| 1 | Claude Opus 4.5 | 45.9% |
| 2 | Claude Sonnet 4.5 | 43.6% |
| 3 | Gemini 3 Pro Preview | 43.3% |

[swebench.com](https://www.swebench.com/)

---

#### METR: Hvor lang tid kan AI arbejde selvstÃ¦ndigt?

METR mÃ¥ler **tidshorisonten** - hvor lange opgaver kan AI lÃ¸se med 50% succes?

| # | Model | 50% Tidshorisont |
|---|-------|------------------|
| 1 | Claude Opus 4.5 | ~4.8 timer |
| 2 | GPT-5.1 Codex Max | ~2.9 timer |
| 3 | GPT-5 | ~2.3 timer |

<br><img src="images/metr-timeline.svg" alt="METR Tidslinje" width="600" style="max-width: 100%;">

**BemÃ¦rk:**
- Tidshorisonten **fordobles hver 7. mÃ¥ned** (konsistent over 6 Ã¥r, dvs. en pendant til Moore's Law)

**Hvis trenden fortsÃ¦tter:**
- 2-4 Ã¥r: ugelange opgaver
- Ã…rtiet ud: mÃ¥nedlange projekter

[metr.org](https://metr.org/blog/2025-03-19-measuring-ai-ability-to-complete-long-tasks/)

---

#### DPAI Arena: Full developer workflow

JetBrains' benchmark - evaluerer hele engineering lifecycle pÃ¥ Spring-projekter (140+ opgaver).

| # | Agent | Model | Score |
|---|-------|-------|-------|
| 1 | Junie CLI 533.2 | Claude Opus 4.5 | 68.9 |
| 2 | Claude Code 2.0.55 | Claude Opus 4.5 | 68.0 |
| 3 | Junie CLI 496.3-prototype | Claude Sonnet 4.5 | 68.0 |

[dpaia.dev](https://dpaia.dev/)

---

### Men pas pÃ¥: Benchmark â‰  virkelighed

METR-studie (juli 2025):
- Erfarne udviklere *troede* de var **20% hurtigere** med AI, nÃ¥r objektive tests viste de var **19% langsommere**

SikkerhedssÃ¥rbarheder ([Stanford/Boneh 2023](https://arxiv.org/abs/2211.03622)):
- Mennesker uden AI: **~50%** sÃ¥rbar kode
- Mennesker MED AI: **~64%** â€” faktisk **vÃ¦rre**!

Forskning tager lang tid og der innoveres med lynets hast, sÃ¥ det handler i hÃ¸j grad om at etablere et vÃ¦ddemÃ¥l.

#!markdown

## Prerequisites Verification

#!markdown

### 1. Er Ollama installeret og kÃ¸rende?

#!csharp

// Test: Kan vi nÃ¥ Ollama?
using System.Net.Http;

var httpClient = new HttpClient();
string selectedModelName = "llama3.1:8b";

try
{
    var response = await httpClient.GetStringAsync("http://localhost:11434/api/tags");
    Console.WriteLine($"âœ… Ollama kÃ¸rer! Model: {selectedModelName}");
}
catch
{
    Console.WriteLine("âŒ Ollama kÃ¸rer IKKE. Start med: ollama serve");
}

#!markdown

---

# Del 1: Agenter - teori og byg din egen
*70 minutter inkl. Ã¸velser*

> **"The LLM never actually touches your filesystem. It just *asks* for things to happen."**
> â€” Mihail Eric, ["The Emperor Has No Clothes"](https://www.mihaileric.com/The-Emperor-Has-No-Clothes/)

AI coding assistants virker som magi, men kernen er simpel:
- **~200 linjer kode** er alt der skal til
- LLM beslutter hvad der skal ske
- **Din kode** udfÃ¸rer handlingerne lokalt
- Resultater sendes tilbage til LLM

### The Agentic Loop - 4 Steps

<img src="images/agentic-loop.svg" alt="Agentic Loop" width="600" style="max-width: 100%;">

**NÃ¸gleindsigt:** LLM'en kalder aldrig noget. Den outputter JSON der siger "Jeg vil gerne kalde X med Y". **Vi** eksekverer det!

#!markdown

## 1.1 Hvad LLM'en Faktisk Ser

Lad os se prÃ¦cis hvad der sendes til Ollama.

#!csharp

// Dette er PRÃ†CIS hvad vi sender til Ollama som tool definition. Det er bare JSON der beskriver en funktion.

var toolJsonExample = """
{
  "type": "function",
  "function": {
    "name": "get_station_status",
    "description": "Get real-time status of an EV charging station",
    "parameters": {
      "type": "object",
      "properties": {
        "stationId": {
          "type": "string",
          "description": "The station ID, e.g., CPH-001"
        }
      },
      "required": ["stationId"]
    }
  }
}
""";

Console.WriteLine("Dette er hvad LLM'en ser som tool definition:");
Console.WriteLine(toolJsonExample);

#!csharp

// Og dette er hvad LLM'en returnerer nÃ¥r den vil bruge et tool

var toolCallResponseExample = """
{
  "message": {
    "role": "assistant",
    "content": "",
    "tool_calls": [
      {
        "function": {
          "name": "get_station_status",
          "arguments": {
            "stationId": "CPH-001"
          }
        }
      }
    ]
  }
}
""";

Console.WriteLine("NÃ¥r LLM'en vil kalde et tool, returnerer den:");
Console.WriteLine(toolCallResponseExample);
Console.WriteLine("\nLLM'en eksekverer ikke noget - den beder os om at gÃ¸re det!");

#!markdown

## 1.2 SimpleTool - Den Transparente Abstraktion

Nu bygger vi vores egen tool-definition.

**Forskellen pÃ¥ SimpleTool og OllamaSharp's indbyggede Tool:**
- `SimpleTool` har en `Execute` funktion - du kan se prÃ¦cis hvad der kÃ¸rer
- `OllamaSharp.Tool` er kun en data-struktur for JSON serialisering, dvs. "automagi"

#!csharp

using System.Text.Json;

record SimpleTool(
    string Name,
    string Description,
    string ParameterSchema,           // Raw JSON
    Func<JsonElement, string> Execute // Selve koden
);

Console.WriteLine($"âœ… {typeof(SimpleTool).Name} defineret!");

#!markdown

## 1.3 ChargeSmart DomÃ¦ne - Mock Data

Vi arbejder med et fiktivt EV-ladenetvÃ¦rk i KÃ¸benhavn:

#!csharp

// Station data (med koordinater til Ã¸velse 4: get_nearest_station)
record StationInfo(string Id, string Name, string Location, int PowerKw, string Type, double Latitude, double Longitude);

var stations = new Dictionary<string, StationInfo>
{
    ["CPH-001"] = new("CPH-001", "NÃ¸rreport Station", "NÃ¸rreport", 150, "ultra-fast", 55.6839, 12.5715),
    ["CPH-002"] = new("CPH-002", "Fisketorvet Parking", "Fisketorvet", 50, "fast", 55.6692, 12.5519),
    ["CPH-003"] = new("CPH-003", "Tivoli Garage", "Tivoli", 50, "fast", 55.6736, 12.5681),
    ["CPH-004"] = new("CPH-004", "Ã˜restad Center", "Ã˜restad", 150, "ultra-fast", 55.6310, 12.5770),
    ["CPH-005"] = new("CPH-005", "Amager Strandpark", "Amager", 22, "slow", 55.6520, 12.6050),
    ["CPH-006"] = new("CPH-006", "NÃ¸rrebro Runddel", "NÃ¸rrebro", 50, "fast", 55.7015, 12.5450),
    ["CPH-007"] = new("CPH-007", "Frederiksberg Have", "Frederiksberg", 7, "slow", 55.6784, 12.5293),
    ["CPH-008"] = new("CPH-008", "Kastrup Lufthavn P4", "Kastrup", 150, "ultra-fast", 55.6180, 12.6560),
    ["CPH-009"] = new("CPH-009", "Valby Langgade", "Valby", 22, "slow", 55.6631, 12.5120),
    ["CPH-010"] = new("CPH-010", "Hellerup Station", "Hellerup", 50, "fast", 55.7280, 12.5720),
};

// Simuler aktive sessioner
var activeSessions = new Dictionary<string, (string vehicleId, DateTime start, double kwh)>
{
    ["CPH-002"] = ("Tesla-Model-3", DateTime.Now.AddMinutes(-45), 28.5),
    ["CPH-004"] = ("Polestar-2", DateTime.Now.AddMinutes(-12), 18.2),
    ["CPH-007"] = ("VW-ID4", DateTime.Now.AddHours(-2), 11.0),
};

// Tarif struktur
decimal GetTariff(int hour) => hour switch
{
    >= 0 and < 6 => 1.50m,      // Off-peak: 00:00-06:00
    >= 6 and < 17 => 2.50m,     // Normal: 06:00-17:00
    >= 17 and < 21 => 4.00m,    // Peak: 17:00-21:00
    >= 21 and <= 23 => 2.50m,   // Normal: 21:00-00:00
    _ => 2.50m
};

Console.WriteLine($"âœ… Loaded {stations.Count} stationer, {activeSessions.Count} aktive sessioner");

#!markdown

## 1.4 Ã˜velse 1: ForstÃ¥ Execute-funktionerne til ChargeSmart Tools
*~15 minutter*

Nu skal du **forstÃ¥ og evt. modificere** `Execute`-funktionerne for 3 ChargeSmart tools.

**ğŸ“‹ Opgave:** FÃ¸r du kÃ¸rer cellen nedenfor:
1. LÃ¦s koden igennem og forstÃ¥ hvad hver funktion gÃ¸r
2. PrÃ¸v at skjule koden og skrive din egen version (brug hints nedenfor)
3. Sammenlign med lÃ¸sningen og kÃ¸r cellen

**Du har adgang til:**
- `stations` - Dictionary med alle stationer (ID â†’ StationInfo)
- `activeSessions` - Dictionary med aktive sessioner (stationId â†’ session info)
- `GetTariff(int hour)` - Returnerer pris pr. kWh for en given time

**Krav til de 3 tools:**

| Tool | Input | Output |
|------|-------|--------|
| `get_station_status` | stationId (string) | Status pÃ¥ Ã©n station (ledig/optaget, kW, type) |
| `list_stations` | *ingen* | Liste over alle stationer med status |
| `calculate_charging_cost` | kwh (number), hour (int) | Pris for at lade X kWh pÃ¥ tidspunkt Y |

#!csharp

// ğŸ¯ Ã˜VELSE 1: Studer disse Execute-funktioner!
// Tip: args er et JsonElement - brug args.GetProperty("name").GetString() osv.

var tools = new Dictionary<string, SimpleTool>
{
    ["get_station_status"] = new(
        Name: "get_station_status",
        Description: "Get real-time status of an EV charging station including availability, power level, and current session info",
        ParameterSchema: """{"type":"object","properties":{"stationId":{"type":"string","description":"Station ID like CPH-001"}},"required":["stationId"]}""",
        Execute: args =>
        {
            // 1. Hent stationId fra args
            var stationId = args.GetProperty("stationId").GetString()!;

            // 2. SlÃ¥ op i stations dictionary
            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            // 3. Tjek om der er en aktiv session
            var hasSession = activeSessions.TryGetValue(stationId, out var session);

            // 4. Returner beskrivende streng
            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
                : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        }
    ),

    ["list_stations"] = new(
        Name: "list_stations",
        Description: "List all EV charging stations in the ChargeSmart network with their current availability",
        ParameterSchema: """{"type":"object","properties":{}}""",
        Execute: _ =>
        {
            // LINQ til at formatere alle stationer
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        }
    ),

    ["calculate_charging_cost"] = new(
        Name: "calculate_charging_cost",
        Description: "Calculate the cost of charging based on kWh needed and time of day",
        ParameterSchema: """{"type":"object","properties":{"kwh":{"type":"number","description":"Energy needed in kWh"},"hour":{"type":"integer","description":"Hour of day (0-23)"}},"required":["kwh","hour"]}""",
        Execute: args =>
        {
            // Handle both number and string JSON values from LLM
            var kwhProp = args.GetProperty("kwh");
            var hourProp = args.GetProperty("hour");
            var kwh = kwhProp.ValueKind == JsonValueKind.String
                ? double.Parse(kwhProp.GetString()!, System.Globalization.CultureInfo.InvariantCulture)
                : kwhProp.GetDouble();
            var hour = hourProp.ValueKind == JsonValueKind.String
                ? int.Parse(hourProp.GetString()!)
                : hourProp.GetInt32();
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;

            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };

            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        }
    )
};

Console.WriteLine($"âœ… Defineret {tools.Count} tools:");
foreach (var tool in tools.Values)
{
    Console.WriteLine($"   - {tool.Name}: {tool.Description.Substring(0, Math.Min(50, tool.Description.Length))}...");
}

#!markdown

### Hints til Ã˜velse 1

<details>
<summary>ğŸ’¡ Hint 1: SÃ¥dan lÃ¦ser du fra JsonElement</summary>

```csharp
// Hent en string property
var stationId = args.GetProperty("stationId").GetString()!;

// Hent et tal (kan vÃ¦re string eller number i JSON)
var kwhProp = args.GetProperty("kwh");
var kwh = kwhProp.ValueKind == JsonValueKind.String
    ? double.Parse(kwhProp.GetString()!, System.Globalization.CultureInfo.InvariantCulture)
    : kwhProp.GetDouble();
```

</details>

<details>
<summary>ğŸ’¡ Hint 2: get_station_status struktur</summary>

```csharp
Execute: args =>
{
    var stationId = args.GetProperty("stationId").GetString()!;

    if (!stations.TryGetValue(stationId, out var station))
        return $"Error: Station {stationId} not found";

    var hasSession = activeSessions.TryGetValue(stationId, out var session);

    // Returner forskellige beskeder baseret pÃ¥ hasSession
    return hasSession
        ? $"Station {stationId}: IN USE..."
        : $"Station {stationId}: AVAILABLE...";
}
```

</details>

<details>
<summary>ğŸ’¡ Hint 3: list_stations med LINQ</summary>

```csharp
Execute: _ =>
{
    var lines = stations.Values.Select(s =>
    {
        var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
        return $"- {s.Id}: {s.Name} - {status}";
    });
    return string.Join("\n", lines);
}
```

</details>

<details>
<summary>âœ… Fuld lÃ¸sning: Alle 3 tools</summary>

```csharp
var tools = new Dictionary<string, SimpleTool>
{
    ["get_station_status"] = new(
        Name: "get_station_status",
        Description: "Get real-time status of an EV charging station including availability, power level, and current session info",
        ParameterSchema: """{"type":"object","properties":{"stationId":{"type":"string","description":"Station ID like CPH-001"}},"required":["stationId"]}""",
        Execute: args =>
        {
            var stationId = args.GetProperty("stationId").GetString()!;

            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            var hasSession = activeSessions.TryGetValue(stationId, out var session);

            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
                : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        }
    ),

    ["list_stations"] = new(
        Name: "list_stations",
        Description: "List all EV charging stations in the ChargeSmart network with their current availability",
        ParameterSchema: """{"type":"object","properties":{}}""",
        Execute: _ =>
        {
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        }
    ),

    ["calculate_charging_cost"] = new(
        Name: "calculate_charging_cost",
        Description: "Calculate the cost of charging based on kWh needed and time of day",
        ParameterSchema: """{"type":"object","properties":{"kwh":{"type":"number","description":"Energy needed in kWh"},"hour":{"type":"integer","description":"Hour of day (0-23)"}},"required":["kwh","hour"]}""",
        Execute: args =>
        {
            var kwhProp = args.GetProperty("kwh");
            var hourProp = args.GetProperty("hour");
            var kwh = kwhProp.ValueKind == JsonValueKind.String
                ? double.Parse(kwhProp.GetString()!, System.Globalization.CultureInfo.InvariantCulture)
                : kwhProp.GetDouble();
            var hour = hourProp.ValueKind == JsonValueKind.String
                ? int.Parse(hourProp.GetString()!)
                : hourProp.GetInt32();
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;

            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };

            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        }
    )
};
```

</details>

#!markdown

### Verificer din lÃ¸sning

KÃ¸r cellen nedenfor for at teste dine Execute-funktioner **uden LLM**:

#!csharp

// Test dine tools direkte!
Console.WriteLine("=== Test get_station_status ===");
var args1 = JsonDocument.Parse("""{"stationId": "CPH-001"}""").RootElement;
Console.WriteLine(tools["get_station_status"].Execute(args1));
Console.WriteLine();

Console.WriteLine("=== Test list_stations ===");
var args2 = JsonDocument.Parse("{}").RootElement;
Console.WriteLine(tools["list_stations"].Execute(args2));
Console.WriteLine();

Console.WriteLine("=== Test calculate_charging_cost ===");
var args3 = JsonDocument.Parse("""{"kwh": 50, "hour": 18}""").RootElement;
Console.WriteLine(tools["calculate_charging_cost"].Execute(args3));
Console.WriteLine();

Console.WriteLine("âœ… Alle tests kÃ¸rte! Hvis du ser output ovenfor, virker dine tools.");

#!markdown

## 1.5 The Agentic Loop - ~50 Lines - det er det hele 

Nu bygger vi det komplette agentic loop fra bunden. Vi skal blot fÃ¸rst oversÃ¦tte vores SimpleTool til OllamaSharp's Tool-type.

#!csharp

#r "nuget: OllamaSharp, 5.3.4"

using OllamaSharp;
using OllamaSharp.Models;
using OllamaSharp.Models.Chat;

Console.WriteLine("âœ… OllamaSharp loaded!");

#!csharp

// HjÃ¦lpefunktion: Konverter SimpleTool til Ollama's Tool format
Tool ToOllamaFormat(SimpleTool simpleTool)
{
    var schemaDoc = JsonDocument.Parse(simpleTool.ParameterSchema);
    var props = schemaDoc.RootElement.GetProperty("properties");
    var required = schemaDoc.RootElement.TryGetProperty("required", out var req)
        ? req.EnumerateArray().Select(x => x.GetString()!).ToArray()
        : Array.Empty<string>();

    var properties = new Dictionary<string, Property>();
    foreach (var prop in props.EnumerateObject())
    {
        properties[prop.Name] = new Property
        {
            Type = prop.Value.GetProperty("type").GetString(),
            Description = prop.Value.TryGetProperty("description", out var desc) ? desc.GetString() : null
        };
    }

    return new Tool
    {
        Type = "function",
        Function = new Function
        {
            Name = simpleTool.Name,
            Description = simpleTool.Description,
            Parameters = new Parameters
            {
                Type = "object",
                Properties = properties,
                Required = required
            }
        }
    };
}

Console.WriteLine("âœ… ToOllamaFormat helper defined");

#!csharp

// THE AGENTIC LOOP - ~50 lines, no magic!
async Task<string> RunAgent(string userMessage, Dictionary<string, SimpleTool> tools)
{
    var ollama = new OllamaApiClient("http://localhost:11434");

    var messages = new List<Message>
    {
        new Message
        {
            Role = OllamaSharp.Models.Chat.ChatRole.System,
            Content = """
                Du er en hjÃ¦lpsom EV-ladnings assistent for ChargeSmart netvÃ¦rket i KÃ¸benhavn.
                Brug de tilgÃ¦ngelige tools til at besvare spÃ¸rgsmÃ¥l om ladestationer,
                tilgÃ¦ngelighed, og priser. Svar altid pÃ¥ dansk.
                """
        },
        new Message { Role = OllamaSharp.Models.Chat.ChatRole.User, Content = userMessage }
    };

    var ollamaTools = tools.Values.Select(ToOllamaFormat).ToList();
    var maxIterations = 10;
    var iteration = 0;

    while (iteration < maxIterations)
    {
        iteration++;
        Console.WriteLine($"\n--- Iteration {iteration} ---");

        // 1. Send til Ollama med tool-definitioner
        var request = new ChatRequest
        {
            Model = selectedModelName ?? "llama3.1:8b",
            Messages = messages,
            Tools = ollamaTools,
            Stream = false
        };

        ChatResponseStream? response = null;
        await foreach (var chunk in ollama.ChatAsync(request))
        {
            response = chunk;
        }

        var assistantMessage = response?.Message;
        if (assistantMessage == null)
            return "Error: No response from LLM";

        messages.Add(assistantMessage);

        // 2. Tjek for tool calls
        if (assistantMessage.ToolCalls == null || !assistantMessage.ToolCalls.Any())
        {
            // Ingen tool calls = LLM er fÃ¦rdig
            Console.WriteLine("âœ… LLM finished (no tool calls)");
            return assistantMessage.Content ?? "No response";
        }

        // 3. EksekvÃ©r hver tool call SELV
        Console.WriteLine($"ğŸ”§ LLM wants to call {assistantMessage.ToolCalls.Count()} tool(s)");

        foreach (var toolCall in assistantMessage.ToolCalls)
        {
            var toolName = toolCall.Function?.Name ?? "unknown";
            Console.WriteLine($"   Tool: {toolName}");
            Console.WriteLine($"   Args: {JsonSerializer.Serialize(toolCall.Function?.Arguments)}");

            // Find og kÃ¸r vores SimpleTool
            if (tools.TryGetValue(toolName, out var tool) && toolCall.Function?.Arguments != null)
            {
                // Konverter arguments til JsonElement
                var argsJson = JsonSerializer.Serialize(toolCall.Function.Arguments);
                var argsElement = JsonDocument.Parse(argsJson).RootElement;

                var result = tool.Execute(argsElement);  // <-- DIN kode kÃ¸rer her!
                Console.WriteLine($"   ğŸ“¤ Result: {result.Substring(0, Math.Min(80, result.Length))}...");

                // 4. TilfÃ¸j resultat til messages
                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = result
                });
            }
            else
            {
                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = $"Error: Unknown tool {toolName}"
                });
            }
        }
        // Loop fortsÃ¦tter - LLM ser resultaterne
    }

    return "Max iterations reached";
}

Console.WriteLine("âœ… RunAgent function defined (~50 lines)");

#!markdown

## 1.6 Ã˜velse 2: Human-in-the-Loop Confirmation
*~15 minutter*

I produktion vil du ofte have tools der gÃ¸r "farlige" ting - f.eks. starter en ladesession, foretager en betaling, eller sletter data. FÃ¸r sÃ¥danne tools eksekveres, bÃ¸r agenten **bede om bekrÃ¦ftelse**.

**Scenarie:** Forestil dig at `calculate_charging_cost` kunne udlÃ¸se en forhÃ¥ndsreservation eller pre-authorization pÃ¥ dit kort. FÃ¸r vi eksekverer det, vil vi gerne have brugerens godkendelse.

**Din opgave:** Modificer loopet sÃ¥ det beder om bekrÃ¦ftelse fÃ¸r "farlige" tools eksekveres.

#!csharp

// ğŸ¯ Ã˜VELSE 2: TilfÃ¸j human-in-the-loop confirmation

// Definer hvilke tools der krÃ¦ver bekrÃ¦ftelse
var dangerousTools = new HashSet<string> { "calculate_charging_cost" };

// Callback-baseret confirmation (dependency injection pattern)
// confirmAction: funktion der tager toolName og returnerer true hvis confirmed
async Task<string> RunAgentWithConfirmation(
    string userMessage,
    Dictionary<string, SimpleTool> tools,
    Func<string, Task<bool>>? confirmAction = null)
{
    var ollama = new OllamaApiClient("http://localhost:11434");

    var messages = new List<Message>
    {
        new Message
        {
            Role = OllamaSharp.Models.Chat.ChatRole.System,
            Content = """
                Du er en hjÃ¦lpsom EV-ladnings assistent for ChargeSmart netvÃ¦rket i KÃ¸benhavn.
                Brug de tilgÃ¦ngelige tools til at besvare spÃ¸rgsmÃ¥l om ladestationer,
                tilgÃ¦ngelighed, og priser. Svar altid pÃ¥ dansk.
                """
        },
        new Message { Role = OllamaSharp.Models.Chat.ChatRole.User, Content = userMessage }
    };

    var ollamaTools = tools.Values.Select(ToOllamaFormat).ToList();
    var maxIterations = 10;
    var iteration = 0;

    while (iteration < maxIterations)
    {
        iteration++;
        Console.WriteLine($"\n--- Iteration {iteration} ---");

        var request = new ChatRequest
        {
            Model = selectedModelName ?? "llama3.1:8b",
            Messages = messages,
            Tools = ollamaTools,
            Stream = false
        };

        ChatResponseStream? response = null;
        await foreach (var chunk in ollama.ChatAsync(request))
        {
            response = chunk;
        }

        var assistantMessage = response?.Message;
        if (assistantMessage == null)
            return "Error: No response from LLM";

        messages.Add(assistantMessage);

        if (assistantMessage.ToolCalls == null || !assistantMessage.ToolCalls.Any())
        {
            Console.WriteLine("âœ… LLM finished (no tool calls)");
            return assistantMessage.Content ?? "No response";
        }

        Console.WriteLine($"ğŸ”§ LLM wants to call {assistantMessage.ToolCalls.Count()} tool(s)");

        foreach (var toolCall in assistantMessage.ToolCalls)
        {
            var toolName = toolCall.Function?.Name ?? "unknown";
            Console.WriteLine($"   Tool: {toolName}");
            Console.WriteLine($"   Args: {JsonSerializer.Serialize(toolCall.Function?.Arguments)}");

            // TODO: TilfÃ¸j bekrÃ¦ftelseslogik her!
            // Hvis toolName er i dangerousTools OG confirmAction != null:
            //   - Kald await confirmAction(toolName)
            //   - Hvis false: skip dette tool call med continue
            //   - Hvis true: fortsÃ¦t med at eksekvere tool

            if (tools.TryGetValue(toolName, out var tool) && toolCall.Function?.Arguments != null)
            {
                var argsJson = JsonSerializer.Serialize(toolCall.Function.Arguments);
                var argsElement = JsonDocument.Parse(argsJson).RootElement;

                var result = tool.Execute(argsElement);
                Console.WriteLine($"   ğŸ“¤ Result: {result.Substring(0, Math.Min(80, result.Length))}...");

                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = result
                });
            }
            else
            {
                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = $"Error: Unknown tool {toolName}"
                });
            }
        }
    }

    return "Max iterations reached";
}

Console.WriteLine("âœ… RunAgentWithConfirmation defined med callback-baseret confirmation!");
Console.WriteLine("ğŸ’¡ Test med cellerne nedenfor:");
Console.WriteLine("   - Auto-confirm: simulerer bruger der siger 'ja'");
Console.WriteLine("   - Auto-reject: simulerer bruger der siger 'nej'");

#!markdown

### Hints til Ã˜velse 2

<details>
<summary>ğŸ’¡ Hint: BekrÃ¦ftelseslogikken</summary>

```csharp
// Tjek om tool er "farligt" OG vi har en confirmAction
if (dangerousTools.Contains(toolName) && confirmAction != null)
{
    Console.WriteLine($"   ğŸ›¡ï¸ Awaiting confirmation for '{toolName}'...");
    var confirmed = await confirmAction(toolName);

    if (!confirmed)
    {
        Console.WriteLine("   â­ï¸  Skipped by user");
        messages.Add(new Message
        {
            Role = OllamaSharp.Models.Chat.ChatRole.Tool,
            Content = $"Tool {toolName} was skipped by user"
        });
        continue;  // Spring til nÃ¦ste tool call
    }
    Console.WriteLine("   âœ… Confirmed by user");
}
```

</details>

<details>
<summary>âœ… Fuld lÃ¸sning: Modificeret loop</summary>

```csharp
foreach (var toolCall in assistantMessage.ToolCalls)
{
    var toolName = toolCall.Function?.Name ?? "unknown";
    Console.WriteLine($"   Tool: {toolName}");
    Console.WriteLine($"   Args: {JsonSerializer.Serialize(toolCall.Function?.Arguments)}");

    // ğŸ›¡ï¸ Human-in-the-loop bekrÃ¦ftelse (callback pattern)
    if (dangerousTools.Contains(toolName) && confirmAction != null)
    {
        Console.WriteLine($"   ğŸ›¡ï¸ Awaiting confirmation for '{toolName}'...");
        var confirmed = await confirmAction(toolName);

        if (!confirmed)
        {
            Console.WriteLine("   â­ï¸  Skipped by user");
            messages.Add(new Message
            {
                Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                Content = $"Tool {toolName} was skipped by user"
            });
            continue;
        }
        Console.WriteLine("   âœ… Confirmed by user");
    }

    if (tools.TryGetValue(toolName, out var tool) && toolCall.Function?.Arguments != null)
    {
        // ... resten af koden
    }
}
```

**LÃ¦rdom:** Human-in-the-loop er kritisk for produktions-agents. Callback-pattern gÃ¸r koden testbar og fleksibel!

</details>

#!markdown

### Test med bekrÃ¦ftelse

NÃ¥r du har implementeret bekrÃ¦ftelseslogikken, test med auto-confirm:

#!csharp

// Test human-in-the-loop med auto-confirm (simulerer bruger der siger "ja")
var result = await RunAgentWithConfirmation(
    "Hvad koster det at lade 50 kWh kl. 18?",
    tools,
    confirmAction: (toolName) => {
        Console.WriteLine($"   ğŸ¤– Auto-confirming '{toolName}'");
        return Task.FromResult(true);
    }
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result);

#!markdown

### Test med afvisning

Test hvad der sker nÃ¥r brugeren afviser:

#!csharp

// Test human-in-the-loop hvor bruger afviser
var result = await RunAgentWithConfirmation(
    "Hvad koster det at lade 50 kWh kl. 18?",
    tools,
    confirmAction: (toolName) => {
        Console.WriteLine($"   ğŸš« Auto-rejecting '{toolName}'");
        return Task.FromResult(false);
    }
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result);

#!markdown

## 1.7 Test din Agent!

#!csharp

var result = await RunAgent(
    "Hvilke ladestationer er ledige lige nu?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result);

#!csharp

var result2 = await RunAgent(
    "Hvad er status pÃ¥ CPH-002?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result2);

#!csharp

var result3 = await RunAgent(
    "Hvad koster det at lade 50 kWh kl. 18? Og hvad hvis jeg venter til kl. 22?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result3);

#!markdown

## Checkpoint Del 1

Du har nu:
1. âœ… Set prÃ¦cis hvad LLM'en modtager (JSON tool definitions)
2. âœ… Set prÃ¦cis hvad LLM'en returnerer (JSON tool calls)
3. âœ… Bygget `SimpleTool` - en transparent tool abstraction
4. âœ… **Ã˜velse 1:** Skrevet Execute-funktioner til 3 ChargeSmart tools
5. âœ… Set det komplette agentic loop (~50 linjer!)
6. âœ… **Ã˜velse 2:** TilfÃ¸jet human-in-the-loop confirmation til loopet
7. âœ… KÃ¸rt en agent med dine tools

**NÃ¸gleindsigt:** Det er sÃ¥ simpelt. ~50 linjer loop + ~10 linjer per tool. *The emperor has no clothes!*

**LÃ¦rdom fra Ã˜velse 2:** I produktion er human-in-the-loop kritisk. Du bestemmer hvilke handlinger der krÃ¦ver godkendelse!

---

#!markdown

# Del 2: Abstraktionsstigen â€“ OllamaSharp.Tool
*15 minutter (valgfri)*

Nu hvor du forstÃ¥r hvad der sker "under the hood", lad os se hvordan OllamaSharp pakker det samme.

#!markdown

## 2.1 Side-by-Side: SimpleTool vs OllamaSharp.Tool

#!csharp

// DIN SimpleTool - alt er synligt:
var simpleToolExample = new SimpleTool(
    Name: "get_station_status",
    Description: "Get EV charging station status",
    ParameterSchema: """{"type":"object","properties":{"stationId":{"type":"string"}},"required":["stationId"]}""",
    Execute: args => $"Station {args.GetProperty("stationId").GetString()} is available"  // <-- Koden er HER
);

// OllamaSharp's Tool - samme data, anden struktur:
var ollamaToolExample = new Tool
{
    Type = "function",
    Function = new Function
    {
        Name = "get_station_status",
        Description = "Get EV charging station status",
        Parameters = new Parameters
        {
            Type = "object",
            Properties = new Dictionary<string, Property>
            {
                ["stationId"] = new Property { Type = "string", Description = "Station ID" }
            },
            Required = new[] { "stationId" }
        }
    }
};
// BEMÃ†RK: Ingen Execute property! Du skal hÃ¥ndtere eksekveringen separat i dit loop.

Console.WriteLine("SimpleTool har:");
Console.WriteLine("  - Name, Description, ParameterSchema");
Console.WriteLine("  - Execute: Func<JsonElement, string> â† KODEN ER HER");
Console.WriteLine();
Console.WriteLine("OllamaSharp.Tool har:");
Console.WriteLine("  - Type, Function (Name, Description, Parameters)");
Console.WriteLine("  - Ingen Execute! â† Du skal selv matche tool calls til kode");

#!markdown

## 2.2 NÃ¸gleindsigt

**OllamaSharp's Tool er bare en data-struktur til JSON serialisering.**

Det er derfor vi byggede `SimpleTool` fÃ¸rst - for at se det fulde billede:
1. Tool *definition* (JSON schema) â†’ sendes til LLM
2. Tool *execution* (din kode) â†’ kÃ¸rer lokalt nÃ¥r LLM requester det

Libraries som OllamaSharp giver dig #1, men du skal selv hÃ¥ndtere #2.
Vores `SimpleTool` pakker begge dele sammen sÃ¥ det er tydeligt.

#!markdown

## 2.3 Ã˜velse: Refaktorer til OllamaSharp.Tool

Konverter Ã©n af dine SimpleTool definitioner til OllamaSharp.Tool format.
Behold samme execution logic i dit loop.

<details>
<summary>Hint: Se lÃ¸sningen</summary>

```csharp
// SimpleTool version:
var getStatus = new SimpleTool(
    Name: "get_station_status",
    // ...
    Execute: args => { /* kode */ }
);

// OllamaSharp version:
var getStatusTool = new Tool {
    Function = new Function {
        Name = "get_station_status",
        // ... (ingen Execute!)
    }
};

// Execution hÃ¥ndteres separat i loop:
if (toolCall.Function.Name == "get_station_status")
{
    result = /* din execution kode */;
}
```

</details>

#!markdown

---

# â˜• PAUSE (15 min)

---

#!markdown

# Del 3: Abstraktionsstigen â€“ MCP
*45 minutter inkl. Ã¸velse*

Vi fortsÃ¦tter op ad abstraktionsstigen: SimpleTool â†’ OllamaSharp.Tool â†’ **MCP**.

## Teori: Model Context Protocol (MCP)

### Problemet: NÃ—M Integrationer

<img src="images/mcp-problem.svg" alt="MCP Problem" width="600" style="max-width: 100%;">

Uden standardisering: Hver agent skal have custom integration til hver tool.

### LÃ¸sningen: MCP som Standard

<img src="images/mcp-solution.svg" alt="MCP Solution" width="600" style="max-width: 100%;">

**MCP = USB-C for AI tools.** *Plug any tool into any agent.*

#!markdown

## 3.1 Hvad Ã†ndrer Sig med MCP?

**FÃ¸r (Del 1-2):** Tools defineret inline i din kode
```csharp
var tools = new Dictionary<string, SimpleTool> {
    ["get_station_status"] = new SimpleTool(..., Execute: args => ...)
};
// Tools lever i din agent kode
```

**Efter (Del 3):** Tools kommer fra eksterne MCP servere
```csharp
var mcpClient = await McpClient.CreateAsync(transport);
var tools = await mcpClient.ListToolsAsync();
// Tools opdages dynamisk fra server!
```

**Samme agent loop, men tools er *"pluggable"*.**

#!markdown

## 3.2 MCP Protocol Basics

MCP bruger **JSON-RPC 2.0** over stdio (lokalt) eller SSE (remote).

Tre hovedoperationer:
1. `initialize` - Handshake mellem client og server
2. `tools/list` - Hent liste af tilgÃ¦ngelige tools
3. `tools/call` - Kald et specifikt tool

#!csharp

// Microsoft.Extensions.AI for AIFunctionFactory
#r "nuget: Microsoft.Extensions.AI, 9.5.0"

using Microsoft.Extensions.AI;

Console.WriteLine("âœ… Microsoft.Extensions.AI indlÃ¦st!");

#!markdown

## 3.3 Ã˜velse 3: AIFunction Tools med Microsoft.Extensions.AI
*~10 minutter*

MCP er designet til **inter-proces** kommunikation (client og server i separate processer).
I en notebook bruger vi i stedet `AIFunctionFactory` fra Microsoft.Extensions.AI, som giver samme tool-oplevelse **in-process**.

> **Note:** I produktion ville du forbinde til en ekstern MCP server via `StdioClientTransport` eller `HttpClientTransport`.

**ğŸ“‹ Opgave:** Sammenlign `AIFunctionFactory.Create()` med `SimpleTool`:
- I Ã˜velse 1 brugte du `SimpleTool` med `Execute: args => { ... }` (JsonElement)
- Her bruger du `AIFunctionFactory.Create((param) => { ... }, "name", "description")`
- Parametrene er **typed** (string, int, double) i stedet for JsonElement!

**BemÃ¦rk:** Logikken er den samme - kun signaturen er anderledes.

#!csharp

// ğŸ¯ Ã˜VELSE 3: Opret AIFunction tools
// Du kender allerede logikken fra Ã˜velse 1 - nu skal du bare bruge en anden signatur!

var aiTools = new List<AITool>
{
    // Eksempel: get_station_status er givet
    AIFunctionFactory.Create(
        (string stationId) =>
        {
            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            var hasSession = activeSessions.TryGetValue(stationId, out var session);
            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
                : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        },
        "get_station_status",
        "Get real-time status of an EV charging station. Parameter: stationId (e.g. CPH-001)"),

    // list_stations - studer denne implementering
    AIFunctionFactory.Create(
        () =>
        {
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        },
        "list_stations",
        "List all EV charging stations in the ChargeSmart network with their current availability"),

    // calculate_charging_cost - studer denne implementering
    AIFunctionFactory.Create(
        (double kwh, int hour) =>
        {
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;
            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };
            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        },
        "calculate_charging_cost",
        "Calculate the cost of charging based on kWh needed and hour of day (0-23)")
};

Console.WriteLine($"ğŸ”Œ Oprettet {aiTools.Count} AIFunction tools:");

#!markdown

### Hints til Ã˜velse 3

<details>
<summary>ğŸ’¡ Hint: list_stations</summary>

```csharp
AIFunctionFactory.Create(
    () =>
    {
        var lines = stations.Values.Select(s =>
        {
            var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
            return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
        });
        return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
    },
    "list_stations",
    "List all EV charging stations...")
```

</details>

<details>
<summary>ğŸ’¡ Hint: calculate_charging_cost</summary>

```csharp
AIFunctionFactory.Create(
    (double kwh, int hour) =>
    {
        var tariff = GetTariff(hour);
        var cost = (decimal)kwh * tariff;
        var period = hour switch
        {
            >= 0 and < 6 => "off-peak",
            >= 17 and < 21 => "peak",
            _ => "normal"
        };
        return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
    },
    "calculate_charging_cost",
    "Calculate the cost of charging...")
```

</details>

<details>
<summary>âœ… Fuld lÃ¸sning: Alle 3 AIFunction tools</summary>

```csharp
var aiTools = new List<AITool>
{
    AIFunctionFactory.Create(
        (string stationId) =>
        {
            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            var hasSession = activeSessions.TryGetValue(stationId, out var session);
            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
                : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        },
        "get_station_status",
        "Get real-time status of an EV charging station. Parameter: stationId (e.g. CPH-001)"),

    AIFunctionFactory.Create(
        () =>
        {
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        },
        "list_stations",
        "List all EV charging stations in the ChargeSmart network with their current availability"),

    AIFunctionFactory.Create(
        (double kwh, int hour) =>
        {
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;
            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };
            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        },
        "calculate_charging_cost",
        "Calculate the cost of charging based on kWh needed and hour of day (0-23)")
};
```

</details>

#!markdown

## 3.4 IChatClient + UseFunctionInvocation()

Her kommer magien - eller rettere, **automationen af det loop du byggede i Del 1!**

OllamaSharp implementerer `IChatClient` fra Microsoft.Extensions.AI.
`UseFunctionInvocation()` automatiserer hele loop'et.

#!csharp

// OllamaApiClient IS an IChatClient!
var ollama = new OllamaApiClient("http://localhost:11434");
ollama.SelectedModel = selectedModelName ?? "llama3.1:8b";

// Wrap med automatisk function invocation
// Dette ER det agentic loop fra Del 1 - bare automatiseret!
IChatClient chatClient = new ChatClientBuilder(ollama)
    .UseFunctionInvocation()  // â† Automatiserer HELE loop'et fra Del 1
    .Build();

Console.WriteLine("âœ… IChatClient med UseFunctionInvocation() klar!");
Console.WriteLine("   - Modtager tool_calls fra LLM");
Console.WriteLine("   - Eksekverer tools automatisk");
Console.WriteLine("   - Sender resultater tilbage");
Console.WriteLine("   - Looper indtil fÃ¦rdig");

#!markdown

## 3.5 Ã˜velse: ChargeSmart med AIFunction Tools

KÃ¸r samme query som i Del 1, men nu med AIFunction tools og automatiseret loop!

**BemÃ¦rk:** Samme tools, samme data - men nu via `IChatClient.UseFunctionInvocation()`.

#!csharp

Console.WriteLine("Sender besked med AIFunction tools...\n");

var messages = new List<ChatMessage>
{
    new(Microsoft.Extensions.AI.ChatRole.User, "Hvilke ladestationer er ledige lige nu? Og hvad koster det at lade 30 kWh kl. 18?")
};

// AIFunction tools + automatisk loop via IChatClient
await foreach (var update in chatClient.GetStreamingResponseAsync(
    messages,
    new() { Tools = [.. aiTools] }))
{
    Console.Write(update.Text);
}

Console.WriteLine("\n\nâœ… Done!")

#!markdown

## Checkpoint Del 3

Du har nu:
1. âœ… ForstÃ¥et MCP som "USB-C for AI tools"
2. âœ… **Ã˜velse 3:** Oprettet tools med `AIFunctionFactory` fra Microsoft.Extensions.AI
3. âœ… Set hvordan `IChatClient.UseFunctionInvocation()` automatiserer loop'et
4. âœ… KÃ¸rt en agent med automatiseret tool invocation

**NÃ¸gleindsigt:** MCP standardiserer tool connectivity. I produktion forbinder du til eksterne MCP servere - i notebooks bruger vi `AIFunctionFactory` som in-process alternativ.

---

#!markdown

# Del 3.5: Ã˜velse 4 - Udvid med get_nearest_station
*~20 minutter*

Nu skal du **studere hvordan man udvider** agenten med et helt nyt tool! Dette er den vigtigste Ã¸velse, fordi det simulerer det typiske workflow: du har en fungerende agent og skal tilfÃ¸je ny funktionalitet.

## Scenarie

En bruger stÃ¥r pÃ¥ gaden og vil finde den **nÃ¦rmeste ledige ladestation**. De kender deres GPS-koordinater og vil have en anbefaling.

**ğŸ“‹ Opgave:** Studer implementeringen nedenfor og forstÃ¥ logikken:
1. Modtag brugerens latitude og longitude
2. Filtrer alle **ledige** stationer (ikke optaget)
3. Beregn afstanden til hver station med Haversine
4. Returner den nÃ¦rmeste

## Stationskoordinater

Alle stationer har nu latitude/longitude (vi tilfÃ¸jede dem i starten):

| Station | Lokation | Latitude | Longitude |
|---------|----------|----------|-----------|
| CPH-001 | NÃ¸rreport | 55.6839 | 12.5715 |
| CPH-002 | Fisketorvet | 55.6692 | 12.5519 |
| CPH-003 | Tivoli | 55.6736 | 12.5681 |
| CPH-004 | Ã˜restad | 55.6310 | 12.5770 |
| CPH-005 | Amager | 55.6520 | 12.6050 |
| CPH-006 | NÃ¸rrebro | 55.7015 | 12.5450 |
| CPH-007 | Frederiksberg | 55.6784 | 12.5293 |
| CPH-008 | Kastrup | 55.6180 | 12.6560 |
| CPH-009 | Valby | 55.6631 | 12.5120 |
| CPH-010 | Hellerup | 55.7280 | 12.5720 |

#!csharp

// ğŸ¯ Ã˜VELSE 4: Implementer get_nearest_station

// Haversine-formlen til at beregne afstand mellem to koordinater (i km)
double CalculateDistance(double lat1, double lon1, double lat2, double lon2)
{
    const double R = 6371; // Jordens radius i km
    var dLat = (lat2 - lat1) * Math.PI / 180;
    var dLon = (lon2 - lon1) * Math.PI / 180;
    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
            Math.Cos(lat1 * Math.PI / 180) * Math.Cos(lat2 * Math.PI / 180) *
            Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
    var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
    return R * c;
}

// Test: Afstand fra RÃ¥dhuspladsen (55.6761, 12.5683) til NÃ¸rreport (CPH-001)
var testDistance = CalculateDistance(55.6761, 12.5683, 55.6839, 12.5715);
Console.WriteLine($"Test: Afstand fra RÃ¥dhuspladsen til NÃ¸rreport: {testDistance:F2} km");

#!csharp

// get_nearest_station - studer denne implementering!

var getNearestStation = AIFunctionFactory.Create(
    (double latitude, double longitude) =>
    {
        // 1. Filtrer ledige stationer
        var availableStations = stations.Values
            .Where(s => !activeSessions.ContainsKey(s.Id))
            .ToList();

        if (!availableStations.Any())
            return "Ingen ledige stationer lige nu!";

        // 2. Find nÃ¦rmeste med LINQ
        var nearest = availableStations
            .Select(s => new {
                Station = s,
                Distance = CalculateDistance(latitude, longitude, s.Latitude, s.Longitude)
            })
            .OrderBy(x => x.Distance)
            .First();

        // 3. Returner beskrivende streng
        return $"NÃ¦rmeste ledige station: {nearest.Station.Id} ({nearest.Station.Name}) - " +
               $"{nearest.Distance:F2} km vÃ¦k. " +
               $"{nearest.Station.PowerKw}kW {nearest.Station.Type} charger ved {nearest.Station.Location}.";
    },
    "get_nearest_station",
    "Find the nearest available charging station. Parameters: latitude and longitude of user's current position"
);

// TilfÃ¸j til aiTools
aiTools.Add(getNearestStation);
Console.WriteLine($"ğŸ”Œ aiTools har nu {aiTools.Count} tools (inkl. get_nearest_station)");

#!markdown

### Hints til Ã˜velse 4

<details>
<summary>ğŸ’¡ Hint 1: Filtrer ledige stationer</summary>

```csharp
var availableStations = stations.Values
    .Where(s => !activeSessions.ContainsKey(s.Id))
    .ToList();

if (!availableStations.Any())
    return "Ingen ledige stationer lige nu!";
```

</details>

<details>
<summary>ğŸ’¡ Hint 2: Beregn afstande og find minimum</summary>

```csharp
var nearest = availableStations
    .Select(s => new {
        Station = s,
        Distance = CalculateDistance(latitude, longitude, s.Latitude, s.Longitude)
    })
    .OrderBy(x => x.Distance)
    .First();
```

</details>

<details>
<summary>âœ… Fuld lÃ¸sning</summary>

```csharp
var getNearestStation = AIFunctionFactory.Create(
    (double latitude, double longitude) =>
    {
        // Filtrer ledige stationer
        var availableStations = stations.Values
            .Where(s => !activeSessions.ContainsKey(s.Id))
            .ToList();

        if (!availableStations.Any())
            return "Ingen ledige stationer lige nu!";

        // Find nÃ¦rmeste
        var nearest = availableStations
            .Select(s => new {
                Station = s,
                Distance = CalculateDistance(latitude, longitude, s.Latitude, s.Longitude)
            })
            .OrderBy(x => x.Distance)
            .First();

        return $"NÃ¦rmeste ledige station: {nearest.Station.Id} ({nearest.Station.Name}) - " +
               $"{nearest.Distance:F2} km vÃ¦k. " +
               $"{nearest.Station.PowerKw}kW {nearest.Station.Type} charger ved {nearest.Station.Location}.";
    },
    "get_nearest_station",
    "Find the nearest available charging station. Parameters: latitude and longitude of user's current position"
);
```

</details>

#!markdown

### Test dit nye tool

#!csharp

// Test get_nearest_station med en position nÃ¦r RÃ¥dhuspladsen
Console.WriteLine("=== Test fra RÃ¥dhuspladsen (55.6761, 12.5683) ===\n");

var messages = new List<ChatMessage>
{
    new(Microsoft.Extensions.AI.ChatRole.User,
        "Jeg stÃ¥r pÃ¥ RÃ¥dhuspladsen (koordinater: 55.6761, 12.5683). Hvor er den nÃ¦rmeste ledige ladestation?")
};

await foreach (var update in chatClient.GetStreamingResponseAsync(
    messages,
    new() { Tools = [.. aiTools] }))
{
    Console.Write(update.Text);
}

Console.WriteLine("\n\nâœ… Test fÃ¦rdig!");

#!markdown

## Checkpoint Ã˜velse 4

Du har nu:
1. âœ… ForstÃ¥et Haversine-formlen til afstandsberegning
2. âœ… Implementeret `get_nearest_station` med LINQ og afstandssortering
3. âœ… Udvidet en eksisterende agent med ny funktionalitet
4. âœ… Testet med en realistisk brugerforespÃ¸rgsel

**LÃ¦rdom:** At udvide en agent er ofte nemmere end at bygge en fra bunden. Du tilfÃ¸jer bare et nyt tool til listen!

---

#!markdown

# Del 4: Skills â€“ teori og prÃ¸v med GitHub Copilot
*25 minutter*

## SEPARAT VEJ

> **Vigtigt:** Dette er en SEPARAT tilgang fra Del 1-3.
> - Del 1-3: Byg din egen agent med Ollama
> - Del 4: Udvid GitHub Copilot med domÃ¦neviden

## Fra domÃ¦ne-specifikke agents til universel kode

**Hvordan vi plejede at tÃ¦nke:**

<img src="images/anthropic-how-we-used-to-think-about-agents.png" alt="Separate agents for each domain" width="600" style="max-width: 100%;">

Vi troede hver domÃ¦ne krÃ¦ver sin egen agent med egne tools og scaffolding.

**Hvad vi opdagede:**

<img src="images/anthropic-code-is-the-universal-interface.png" alt="Code is the universal interface" width="600" style="max-width: 100%;">

Kode er ikke bare en use case â€“ det er den universelle grÃ¦nseflade til den digitale verden.

En coding agent kan:
- Kalde API'er for at hente data (research)
- Organisere data i filsystemet (dokumenter)
- Analysere med Python (finans)
- Generere output i ethvert format (marketing)

**Konklusion**: Vi behÃ¸ver ikke mange forskellige agents â€“ vi behÃ¸ver Ã‰N general-purpose coding agent + **skills** der giver domÃ¦neekspertise.

## Teori: Hvorfor Skills?

**Problemet:** Giv en model 100 tools, og den bliver forvirret. Tool selection degraderer.

**LÃ¸sningen:** Skills = "lazy-loaded expertise"
- En "router" klassificerer fÃ¸rst brugerens intent
- Kun relevante tools/knowledge indlÃ¦ses
- Modellen fokuserer pÃ¥ Ã©n opgave ad gangen

**Key insight:** Copilot har allerede loopet, LLM, og basale tools. Du tilfÃ¸jer domÃ¦neviden!

#!markdown

## 4.1 GitHub Copilot Agent Mode

VS Code 1.108+ har eksperimentel support for "agent skills".

### Aktivering

1. Ã…bn VS Code Settings (Ctrl+,)
2. SÃ¸g efter `chat.useAgentSkills`
3. Aktiver indstillingen

### Skill Struktur

```
.github/skills/
â””â”€â”€ ev-charging-advisor/
    â””â”€â”€ SKILL.md
```

Copilot scanner automatisk `.github/skills/` og indlÃ¦ser relevante skills.

#!markdown

## 4.2 SKILL.md Anatomi

```yaml
---
name: my-skill
description: Kort beskrivelse til discovery
triggers:
  - "nÃ¥r bruger spÃ¸rger om X"
  - "nÃ¥r der er behov for Y"
---

# Detaljerede Instruktioner

Her kommer den fulde domÃ¦neviden...
```

- **YAML frontmatter:** Metadata til skill discovery
- **Markdown body:** Instruktioner, eksempler, context

#!markdown

## 4.3 Ã˜velse: Opret EV Charging Advisor Skill

### Step 1: Opret skill mappe

**PowerShell:**
```powershell
New-Item -ItemType Directory -Force -Path ".github/skills/ev-charging-advisor"
```

**Bash:**
```bash
mkdir -p .github/skills/ev-charging-advisor
```

### Step 2: Opret SKILL.md

Opret filen `.github/skills/ev-charging-advisor/SKILL.md`:

```yaml
---
name: ev-charging-advisor
description: EkspertrÃ¥dgivning om optimering af elbil-ladning pÃ¥ ChargeSmart netvÃ¦rket
triggers:
  - "nÃ¥r bruger spÃ¸rger om ladepris"
  - "nÃ¥r bruger vil finde billigste ladetidspunkt"
  - "nÃ¥r bruger spÃ¸rger om batteri-tips"
  - "nÃ¥r bruger nÃ¦vner ChargeSmart eller elbil-ladning"
---

# EV Charging Advisor

Du er en ekspert i at optimere elbil-ladning pÃ¥ ChargeSmart netvÃ¦rket i KÃ¸benhavn.

## ChargeSmart Tarif-struktur

| Periode | Tid | Pris/kWh |
|---------|-----|----------|
| Off-peak | 00:00-06:00 | 1.50 DKK |
| Normal | 06:00-17:00, 21:00-00:00 | 2.50 DKK |
| Peak | 17:00-21:00 | 4.00 DKK |

## Stationer i NetvÃ¦rket

- CPH-001: NÃ¸rreport Station - 150kW ultra-fast
- CPH-002: Fisketorvet Parking - 50kW fast
- CPH-003: Tivoli Garage - 50kW fast
- CPH-004: Ã˜restad Center - 150kW ultra-fast
- CPH-005: Amager Strandpark - 22kW slow
- CPH-006: NÃ¸rrebro Runddel - 50kW fast
- CPH-007: Frederiksberg Have - 7kW slow
- CPH-008: Kastrup Lufthavn P4 - 150kW ultra-fast
- CPH-009: Valby Langgade - 22kW slow
- CPH-010: Hellerup Station - 50kW fast

## Instruktioner

NÃ¥r bruger spÃ¸rger om ladning:

1. **Identificer behov** - Hvor mange kWh skal de lade?
2. **Tjek tidspunkt** - HvornÃ¥r vil de lade?
3. **Beregn pris** - Brug tarif-tabellen
4. **Optimer** - ForeslÃ¥ ALTID billigere alternativer
5. **Batteri-tips** - TilfÃ¸j relevante tips

## Batteri-tips

- UndgÃ¥ at lade til 100% dagligt (80% er optimalt for battery health)
- UndgÃ¥ at kÃ¸re under 20% regelmÃ¦ssigt
- Forvarm batteri i koldt vejr fÃ¸r hurtigladning
- Ultra-fast ladning (150kW) slider mere pÃ¥ batteriet end langsom ladning

## Eksempel-dialog

**Bruger:** Hvad koster det at lade 40 kWh kl. 18?

**Svar:** At lade 40 kWh kl. 18:00 koster **160 DKK** (peak-tarif: 4.00 DKK/kWh).

ğŸ’¡ **Tip:** Hvis du kan vente til kl. 21:00, falder prisen til **100 DKK** (normal-tarif).
Eller endnu bedre - lad natten over (kl. 00-06) for kun **60 DKK**!

ğŸ”‹ **Batteri-tip:** Hvis du ikke behÃ¸ver fuld opladning, sÃ¥ lad kun til 80% for at forlÃ¦nge batteriets levetid.
```

#!markdown

### Step 3: Test med Copilot Chat

1. Ã…bn **Copilot Chat** i VS Code (Ctrl+Alt+I)
2. PrÃ¸v disse prompts:
   - "Hvad koster det at lade 50 kWh kl. 18?"
   - "Find den billigste tid at lade min elbil"
   - "Giv mig tips til at forlÃ¦nge mit EV batteri"

Copilot burde nu bruge din skill til at give ChargeSmart-specifikke svar! (Det er tilfÃ¦lded hvis du ser beskeden "Read SKILL.md file".)

#!markdown

## Checkpoint Del 4

Du har nu:
1. âœ… ForstÃ¥et Skills som "lazy-loaded expertise"
2. âœ… Oprettet en SKILL.md med domÃ¦neviden
3. âœ… Udvidet GitHub Copilot med ChargeSmart ekspertise

**NÃ¸gleindsigt:** Du behÃ¸ver ikke bygge en agent - du kan udvide Ã©n du allerede har!

---

#!markdown

# Afrunding
*10 minutter*

## To Separate Veje - Recap

### Vej A: Byg Din Egen Agent (Del 1-3)

```
SimpleTool â†’ OllamaSharp.Tool â†’ MCP Server
```

- Samme funktionalitet, stigende abstraktion
- Fuld kontrol, fuld forstÃ¥else
- **Brug nÃ¥r:** Custom agents, embedded systems, specifikke workflows

### Vej B: Udvid en Eksisterende Agent (Del 4)

```
GitHub Copilot + SKILL.md â†’ DomÃ¦neviden
```

- Byg ikke infrastruktur - tilfÃ¸j viden
- **Brug nÃ¥r:** Produktivitet, team workflows, quick wins

## Key Takeaways

1. **Agents er simple** - ~200 linjer loop kode
2. **"Magien" er i LLM'en** - ikke infrastrukturen
3. **MCP standardiserer** - USB-C for AI tools
4. **Skills tilfÃ¸jer viden** - uden at genopbygge

## NÃ¦ste Skridt: Enterprise Agent SDK'er

Nu hvor du har bygget din egen agent-loop og forstÃ¥r abstraktionerne, kan du udforske etablerede SDK'er. Disse giver dig **observability**, **multi-agent orchestration** og **enterprise compliance** ud af boksen â€“ men bygger pÃ¥ prÃ¦cis de samme principper, du har lÃ¦rt i dag.

**To tilgange dominerer:**

| | **Anthropic Claude Agent SDK** | **Microsoft Agent Framework** |
|---|---|---|
| **Filosofi** | "Giv Claude en computer" | "Unified multi-agent orchestration" |
| **Kerne** | Bash/fil-tools, subagents, MCP | AutoGen + Semantic Kernel |
| **Sprog** | Python | Python, C#, Java |
| **Styrke** | Simpel agent â†’ computer-interaktion | Enterprise: observability, compliance, A2A |
| **MCP** | âœ… Native integration | âœ… Native integration |

![Agent SDK Landscape](images/agent-sdk-landscape.svg)

> **NÃ¸gleindsigt:** Begge SDK'er bygger pÃ¥ de samme principper, du har lÃ¦rt (tools, loops, MCP). Forskellen ligger i *hvor meget* infrastruktur du fÃ¥r "gratis" â€“ og *hvilken leverandÃ¸r* du binder dig til.

## The Emperor Has No Clothes

> **"The core of these tools isn't magic. It's about 200 lines of straightforward Python."**
> â€” Mihail Eric

Du har nu set det selv. Du kan bygge en agent. Du forstÃ¥r hvad der sker.

**Hvorfor er dette vigtigt?**

> Whilst software development/programming is now dead. We however deeply need software engineers with these skills who understand that LLMs are a new form of programmable computer. If you havenâ€™t built your own coding agent yet - please do.
> â€” [Geoffrey Huntley](https://ghuntley.com/loop/)


## Ressourcer

- [MCP Documentation](https://modelcontextprotocol.io)
- [Microsoft.Extensions.AI](https://github.com/dotnet/extensions)
- [GitHub Copilot Skills](https://docs.github.com/en/copilot)
- [The Emperor Has No Clothes](https://www.mihaileric.com/The-Emperor-Has-No-Clothes/)
- [OllamaSharp](https://github.com/awaescher/OllamaSharp)
- [Building agents with the Claude Agent SDK](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk)
- [Introducing Microsoft Agent Framework](https://azure.microsoft.com/en-us/blog/introducing-microsoft-agent-framework/)

---

## Tak for i dag! ğŸ‰
