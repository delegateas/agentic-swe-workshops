#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

# Agents, MCP & Skills

En praktisk workshop hvor vi udforsker den nye verden af **agentic software engineering**.

---

## Agenda (ca. 3,5 timer)

| Tid | Emne |
|-----|------|
| 25 min | Intro, Recap & Polyglot Notebooks |
| 60 min | Agenter - teori og byg din egen |
| 20 min | Abstraktionsstigen â€“ OllamaSharp.Tool |
| 15 min | *Pause* |
| 50 min | Abstraktionsstigen â€“ MCP |
| 40 min | Skills â€“ teori og prÃ¸v med GitHub Copilot |
| 10 min | Afrunding |

---

## To Separate Veje

```
VEJ A: Byg Din Egen Agent (Del 1-3)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Del 1: SimpleTool + Manuel Loop                             â”‚
â”‚     â†“ "Jeg forstÃ¥r hvordan det virker"                       â”‚
â”‚  Del 2: OllamaSharp.Tool (samme, men bibliotek)              â”‚
â”‚     â†“ "Bibliotek pakker de samme koncepter"                  â”‚
â”‚  Del 3: MCP erstatter inline tools                           â”‚
â”‚     â†’ Samme agent, men tools fra MCP servere                 â”‚
â”‚     â†’ IChatClient + UseFunctionInvocation() = automatisk loopâ”‚
â”‚     â†’ "USB-C metafor" - standardiseret connectivity          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VEJ B: Udvid en Eksisterende Agent (Del 4 - SEPARAT)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Del 4: GitHub Copilot + SKILL.md                            â”‚
â”‚     â†’ Byg ikke en agent, udvid Ã©n du allerede har            â”‚
â”‚     â†’ SKILL.md filer tilfÃ¸jer domÃ¦neviden                    â”‚
â”‚     â†’ Copilot har allerede loopet, LLM, tools                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Disse veje integrerer IKKE!** De er alternative tilgange.

---

#!markdown

# Del 0: Intro, Recap & Polyglot Notebooks
*25 minutter*

#!markdown

## Opsummering fra sidste gang

- LLMs & Agents - What are they, and why can they code? â€” Martin
- Agentisk softwareudvikling for personlig produktivitet â€” Emil
- Agentisk Software Engineering for fuld SDLC af et produkt â€” Magnus

Lige denne planche er meget relevant mht. dagens seance: [How LLMs Learn: The Three Stages](https://martinrl.github.io/presentations/what-are-llms-and-agents/index.html#14)

<img src="images/LLMs-14.png" alt="LLMs-14" width="600" style="max-width: 100%;">

---

#!markdown

## Intro til Polyglot Notebooks

### Hvad er en Polyglot Notebook?

- `.dib` format (tidligere `.dotnet-interactive`)
- KÃ¸rer pÃ¥ .NET Interactive kernel
- UnderstÃ¸tter flere sprog: C#, F#, HTML, Mermaid, PowerShell, JavaScript, SQL, KQL

### SÃ¥dan kÃ¸rer du en celle

- **Shift+Enter** - KÃ¸r celle og gÃ¥ til nÃ¦ste
- **Ctrl+Enter** - KÃ¸r celle og bliv
- Variabler persisterer pÃ¥ tvÃ¦rs af celler

#!csharp

Console.WriteLine("Hello EV World!");

#!markdown

---

## Det Agentiske Landskab â€“ Benchmarks

<img src="images/Orloff-1600x1067.webp" alt="Professor Orloff" width="600" style="max-width: 100%;">
<br><br>

> An LLM is just a brain in a jar. ğŸ§ 

â€” [Simon Maple](https://www.linkedin.com/in/simonmaple/), Head of Developer Relations @ Tessl ([AI Native podcast](https://open.spotify.com/episode/1HYcUlgkCa9VwvVfuy3fyx?nd=1&dlsi=a77f69fabf8b46b1))

### Hvorfor kan LLM'er kode sÃ¥ godt nu?

**Kode har indbygget feedback.** Til forskel fra "god tekst" kan vi objektivt mÃ¥le om kode virker:
- Kompilerer det? âœ…/âŒ
- BestÃ¥r tests? âœ…/âŒ
- LÃ¸ser det opgaven? âœ…/âŒ

Dette muliggÃ¸r **RLVR** (*Reinforcement Learning with Verifiable Rewards*):

<img src="images/ai-training-loop.svg" alt="AI TrÃ¦ningsloop" width="600" style="max-width: 100%;">

#!markdown

### Benchmarks (pr. januar 2026)

#### SWE-bench: LÃ¸s rigtige GitHub issues

**SWE-bench Verified** (500 human-validerede issues):

| # | Model | Score |
|---|-------|-------|
| 1 | Claude Opus 4.5 | 80.9% |
| 2 | GPT-5.2 | 75.4% |
| 3 | Claude Opus 4.1 | 74.5% |

**SWE-bench Pro** (1865 svÃ¦rere issues, nye repos):

| # | Agent | Score |
|---|-------|-------|
| 1 | Claude Opus 4.5 | 45.9% |
| 2 | Claude Sonnet 4.5 | 43.6% |
| 3 | Gemini 3 Pro Preview | 43.3% |

[swebench.com](https://www.swebench.com/)

---

#### METR: Hvor lang tid kan AI arbejde selvstÃ¦ndigt?

METR mÃ¥ler **tidshorisonten** - hvor lange opgaver kan AI lÃ¸se med 50% succes?

| # | Model | 50% Tidshorisont |
|---|-------|------------------|
| 1 | Claude Opus 4.5 | ~4.8 timer |
| 2 | GPT-5.1 Codex Max | ~2.9 timer |
| 3 | GPT-5 | ~2.3 timer |

<br><img src="images/metr-timeline.svg" alt="METR Tidslinje" width="600" style="max-width: 100%;">

**BemÃ¦rk:**
- Tidshorisonten **fordobles hver 7. mÃ¥ned** (konsistent over 6 Ã¥r, dvs. en pendant til Moore's Law)

**Hvis trenden fortsÃ¦tter:**
- 2-4 Ã¥r: ugelange opgaver
- Ã…rtiet ud: mÃ¥nedlange projekter

[metr.org](https://metr.org/blog/2025-03-19-measuring-ai-ability-to-complete-long-tasks/)

---

#### DPAI Arena: Full developer workflow

JetBrains' benchmark - evaluerer hele engineering lifecycle pÃ¥ Spring-projekter (140+ opgaver).

| # | Agent | Model | Score |
|---|-------|-------|-------|
| 1 | Junie CLI 533.2 | Claude Opus 4.5 | 68.9 |
| 2 | Claude Code 2.0.55 | Claude Opus 4.5 | 68.0 |
| 3 | Junie CLI 496.3-prototype | Claude Sonnet 4.5 | 68.0 |

[dpaia.dev](https://dpaia.dev/)

---

### Men pas pÃ¥: Benchmark â‰  virkelighed

METR-studie (juli 2025):
- Erfarne udviklere *troede* de var **20% hurtigere** med AI, nÃ¥r objektive tests viste de var **19% langsommere**

SikkerhedssÃ¥rbarheder ([Stanford/Boneh 2023](https://arxiv.org/abs/2211.03622)):
- Mennesker uden AI: **~50%** sÃ¥rbar kode
- Mennesker MED AI: **~64%** â€” faktisk **vÃ¦rre**!

Forskning tager lang tid og der innoveres med lynets hast, sÃ¥ det handler i hÃ¸j grad om at etablere et vÃ¦ddemÃ¥l.

#!markdown

## Prerequisites Verification

#!markdown

### 1. Er Ollama installeret og kÃ¸rende?

**Windows (PowerShell):**
```powershell
winget install Ollama.Ollama
```

**Mac (Homebrew):**
```bash
brew install ollama
```

Start Ollama og hiv modellen ned:
```bash
ollama serve
ollama pull llama3.1:8b
```

ğŸ‘†ğŸ» kan ogsÃ¥ foretages i GUI; vÃ¦lg model, skriv en prompt (f.eks. "hej") og tryk retur

#!csharp

// Test: Kan vi nÃ¥ Ollama?
using System.Net.Http;

var httpClient = new HttpClient();
string selectedModelName = "llama3.1:8b";

try
{
    var response = await httpClient.GetStringAsync("http://localhost:11434/api/tags");
    Console.WriteLine($"âœ… Ollama kÃ¸rer! Model: {selectedModelName}");
}
catch
{
    Console.WriteLine("âŒ Ollama kÃ¸rer IKKE. Start med: ollama serve");
}

#!markdown

---

# Del 1: Agenter - teori og byg din egen
*60 minutter*

> **"The LLM never actually touches your filesystem. It just *asks* for things to happen."**
> â€” Mihail Eric, ["The Emperor Has No Clothes"](https://www.mihaileric.com/The-Emperor-Has-No-Clothes/)

AI coding assistants virker som magi, men kernen er simpel:
- **~200 linjer kode** er alt der skal til
- LLM beslutter hvad der skal ske
- **Din kode** udfÃ¸rer handlingerne lokalt
- Resultater sendes tilbage til LLM

### The Agentic Loop - 4 Steps

<img src="images/agentic-loop.svg" alt="Agentic Loop" width="600" style="max-width: 100%;">

**NÃ¸gleindsigt:** LLM'en kalder aldrig noget. Den outputter JSON der siger "Jeg vil gerne kalde X med Y". **Vi** eksekverer det!

#!markdown

## 1.1 Hvad LLM'en Faktisk Ser

Lad os se prÃ¦cis hvad der sendes til Ollama.

#!csharp

// Dette er PRÃ†CIS hvad vi sender til Ollama som tool definition. Det er bare JSON der beskriver en funktion.

var toolJsonExample = """
{
  "type": "function",
  "function": {
    "name": "get_station_status",
    "description": "Get real-time status of an EV charging station",
    "parameters": {
      "type": "object",
      "properties": {
        "stationId": {
          "type": "string",
          "description": "The station ID, e.g., CPH-001"
        }
      },
      "required": ["stationId"]
    }
  }
}
""";

Console.WriteLine("Dette er hvad LLM'en ser som tool definition:");
Console.WriteLine(toolJsonExample);

#!csharp

// Og dette er hvad LLM'en returnerer nÃ¥r den vil bruge et tool

var toolCallResponseExample = """
{
  "message": {
    "role": "assistant",
    "content": "",
    "tool_calls": [
      {
        "function": {
          "name": "get_station_status",
          "arguments": {
            "stationId": "CPH-001"
          }
        }
      }
    ]
  }
}
""";

Console.WriteLine("NÃ¥r LLM'en vil kalde et tool, returnerer den:");
Console.WriteLine(toolCallResponseExample);
Console.WriteLine("\nLLM'en eksekverer ikke noget - den beder os om at gÃ¸re det!");

#!markdown

## 1.2 SimpleTool - Den Transparente Abstraktion

Nu bygger vi vores egen tool-definition.

**Forskellen pÃ¥ SimpleTool og OllamaSharp's indbyggede Tool:**
- `SimpleTool` har en `Execute` funktion - du kan se prÃ¦cis hvad der kÃ¸rer
- `OllamaSharp.Tool` er kun en data-struktur for JSON serialisering

#!csharp

using System.Text.Json;

record SimpleTool(
    string Name,
    string Description,
    string ParameterSchema,           // Raw JSON - fuldt synligt
    Func<JsonElement, string> Execute // Selve koden - lige her!
);

Console.WriteLine($"âœ… {typeof(SimpleTool).Name} defineret!");

#!markdown

## 1.3 ChargeSmart DomÃ¦ne - Mock Data

Vi arbejder med et fiktivt EV-ladenetvÃ¦rk i KÃ¸benhavn:

#!csharp

// Station data
record StationInfo(string Id, string Name, string Location, int PowerKw, string Type);

var stations = new Dictionary<string, StationInfo>
{
    ["CPH-001"] = new("CPH-001", "NÃ¸rreport Station", "NÃ¸rreport", 150, "ultra-fast"),
    ["CPH-002"] = new("CPH-002", "Fisketorvet Parking", "Fisketorvet", 50, "fast"),
    ["CPH-003"] = new("CPH-003", "Tivoli Garage", "Tivoli", 50, "fast"),
    ["CPH-004"] = new("CPH-004", "Ã˜restad Center", "Ã˜restad", 150, "ultra-fast"),
    ["CPH-005"] = new("CPH-005", "Amager Strandpark", "Amager", 22, "slow"),
    ["CPH-006"] = new("CPH-006", "NÃ¸rrebro Runddel", "NÃ¸rrebro", 50, "fast"),
    ["CPH-007"] = new("CPH-007", "Frederiksberg Have", "Frederiksberg", 7, "slow"),
    ["CPH-008"] = new("CPH-008", "Kastrup Lufthavn P4", "Kastrup", 150, "ultra-fast"),
    ["CPH-009"] = new("CPH-009", "Valby Langgade", "Valby", 22, "slow"),
    ["CPH-010"] = new("CPH-010", "Hellerup Station", "Hellerup", 50, "fast"),
};

// Simuler aktive sessioner
var activeSessions = new Dictionary<string, (string vehicleId, DateTime start, double kwh)>
{
    ["CPH-002"] = ("Tesla-Model-3", DateTime.Now.AddMinutes(-45), 28.5),
    ["CPH-004"] = ("Polestar-2", DateTime.Now.AddMinutes(-12), 18.2),
    ["CPH-007"] = ("VW-ID4", DateTime.Now.AddHours(-2), 11.0),
};

// Tarif struktur
decimal GetTariff(int hour) => hour switch
{
    >= 0 and < 6 => 1.50m,      // Off-peak: 00:00-06:00
    >= 6 and < 17 => 2.50m,     // Normal: 06:00-17:00
    >= 17 and < 21 => 4.00m,    // Peak: 17:00-21:00
    >= 21 and <= 23 => 2.50m,   // Normal: 21:00-00:00
    _ => 2.50m
};

Console.WriteLine($"âœ… Loaded {stations.Count} stationer, {activeSessions.Count} aktive sessioner");

#!markdown

## 1.4 Definer ChargeSmart Tools

Nu definerer vi 3 tools med vores SimpleTool record:

#!csharp

var tools = new Dictionary<string, SimpleTool>
{
    ["get_station_status"] = new(
        Name: "get_station_status",
        Description: "Get real-time status of an EV charging station including availability, power level, and current session info",
        ParameterSchema: """{"type":"object","properties":{"stationId":{"type":"string","description":"Station ID like CPH-001"}},"required":["stationId"]}""",
        Execute: args =>
        {
            var stationId = args.GetProperty("stationId").GetString()!;

            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            var hasSession = activeSessions.TryGetValue(stationId, out var session);

            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
            : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        }
    ),

    ["list_stations"] = new(
        Name: "list_stations",
        Description: "List all EV charging stations in the ChargeSmart network with their current availability",
        ParameterSchema: """{"type":"object","properties":{}}""",
        Execute: _ =>
        {
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        }
    ),

    ["calculate_charging_cost"] = new(
        Name: "calculate_charging_cost",
        Description: "Calculate the cost of charging based on kWh needed and time of day",
        ParameterSchema: """{"type":"object","properties":{"kwh":{"type":"number","description":"Energy needed in kWh"},"hour":{"type":"integer","description":"Hour of day (0-23)"}},"required":["kwh","hour"]}""",
        Execute: args =>
        {
            // Handle both number and string JSON values from LLM
            var kwhProp = args.GetProperty("kwh");
            var hourProp = args.GetProperty("hour");
            var kwh = kwhProp.ValueKind == JsonValueKind.String
                ? double.Parse(kwhProp.GetString()!, System.Globalization.CultureInfo.InvariantCulture)
                : kwhProp.GetDouble();
            var hour = hourProp.ValueKind == JsonValueKind.String
                ? int.Parse(hourProp.GetString()!)
                : hourProp.GetInt32();
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;

            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };

            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        }
    )
};

Console.WriteLine($"âœ… Defineret {tools.Count} tools:");
foreach (var tool in tools.Values)
{
    Console.WriteLine($"   - {tool.Name}: {tool.Description.Substring(0, Math.Min(50, tool.Description.Length))}...");
}

#!markdown

### Test tools direkte (uden LLM)

#!csharp

// Test get_station_status
var args1 = JsonDocument.Parse("""{"stationId": "CPH-001"}""").RootElement;
Console.WriteLine(tools["get_station_status"].Execute(args1));
Console.WriteLine();

// Test list_stations
var args2 = JsonDocument.Parse("{}").RootElement;
Console.WriteLine(tools["list_stations"].Execute(args2));
Console.WriteLine();

// Test calculate_charging_cost
var args3 = JsonDocument.Parse("""{"kwh": 50, "hour": 18}""").RootElement;
Console.WriteLine(tools["calculate_charging_cost"].Execute(args3));

#!markdown

## 1.5 The Agentic Loop - ~50 Lines, No Magic

Nu bygger vi det komplette agentic loop fra bunden.

#!csharp

#r "nuget: OllamaSharp, 5.3.4"

using OllamaSharp;
using OllamaSharp.Models;
using OllamaSharp.Models.Chat;

Console.WriteLine("âœ… OllamaSharp loaded!");

#!csharp

// HjÃ¦lpefunktion: Konverter SimpleTool til Ollama's Tool format
Tool ToOllamaFormat(SimpleTool simpleTool)
{
    var schemaDoc = JsonDocument.Parse(simpleTool.ParameterSchema);
    var props = schemaDoc.RootElement.GetProperty("properties");
    var required = schemaDoc.RootElement.TryGetProperty("required", out var req)
        ? req.EnumerateArray().Select(x => x.GetString()!).ToArray()
        : Array.Empty<string>();

    var properties = new Dictionary<string, Property>();
    foreach (var prop in props.EnumerateObject())
    {
        properties[prop.Name] = new Property
        {
            Type = prop.Value.GetProperty("type").GetString(),
            Description = prop.Value.TryGetProperty("description", out var desc) ? desc.GetString() : null
        };
    }

    return new Tool
    {
        Type = "function",
        Function = new Function
        {
            Name = simpleTool.Name,
            Description = simpleTool.Description,
            Parameters = new Parameters
            {
                Type = "object",
                Properties = properties,
                Required = required
            }
        }
    };
}

Console.WriteLine("âœ… ToOllamaFormat helper defined");

#!csharp

// THE AGENTIC LOOP - ~50 lines, no magic!
async Task<string> RunAgent(string userMessage, Dictionary<string, SimpleTool> tools)
{
    var ollama = new OllamaApiClient("http://localhost:11434");

    var messages = new List<Message>
    {
        new Message
        {
            Role = OllamaSharp.Models.Chat.ChatRole.System,
            Content = """
                Du er en hjÃ¦lpsom EV-ladnings assistent for ChargeSmart netvÃ¦rket i KÃ¸benhavn.
                Brug de tilgÃ¦ngelige tools til at besvare spÃ¸rgsmÃ¥l om ladestationer,
                tilgÃ¦ngelighed, og priser. Svar altid pÃ¥ dansk.
                """
        },
        new Message { Role = OllamaSharp.Models.Chat.ChatRole.User, Content = userMessage }
    };

    var ollamaTools = tools.Values.Select(ToOllamaFormat).ToList();
    var maxIterations = 10;
    var iteration = 0;

    while (iteration < maxIterations)
    {
        iteration++;
        Console.WriteLine($"\n--- Iteration {iteration} ---");

        // 1. Send til Ollama med tool-definitioner
        var request = new ChatRequest
        {
            Model = selectedModelName ?? "llama3.1:8b",
            Messages = messages,
            Tools = ollamaTools,
            Stream = false
        };

        ChatResponseStream? response = null;
        await foreach (var chunk in ollama.ChatAsync(request))
        {
            response = chunk;
        }

        var assistantMessage = response?.Message;
        if (assistantMessage == null)
            return "Error: No response from LLM";

        messages.Add(assistantMessage);

        // 2. Tjek for tool calls
        if (assistantMessage.ToolCalls == null || !assistantMessage.ToolCalls.Any())
        {
            // Ingen tool calls = LLM er fÃ¦rdig
            Console.WriteLine("âœ… LLM finished (no tool calls)");
            return assistantMessage.Content ?? "No response";
        }

        // 3. EksekvÃ©r hver tool call SELV
        Console.WriteLine($"ğŸ”§ LLM wants to call {assistantMessage.ToolCalls.Count()} tool(s)");

        foreach (var toolCall in assistantMessage.ToolCalls)
        {
            var toolName = toolCall.Function?.Name ?? "unknown";
            Console.WriteLine($"   Tool: {toolName}");
            Console.WriteLine($"   Args: {JsonSerializer.Serialize(toolCall.Function?.Arguments)}");

            // Find og kÃ¸r vores SimpleTool
            if (tools.TryGetValue(toolName, out var tool) && toolCall.Function?.Arguments != null)
            {
                // Konverter arguments til JsonElement
                var argsJson = JsonSerializer.Serialize(toolCall.Function.Arguments);
                var argsElement = JsonDocument.Parse(argsJson).RootElement;

                var result = tool.Execute(argsElement);  // <-- DIN kode kÃ¸rer her!
                Console.WriteLine($"   ğŸ“¤ Result: {result.Substring(0, Math.Min(80, result.Length))}...");

                // 4. TilfÃ¸j resultat til messages
                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = result
                });
            }
            else
            {
                messages.Add(new Message
                {
                    Role = OllamaSharp.Models.Chat.ChatRole.Tool,
                    Content = $"Error: Unknown tool {toolName}"
                });
            }
        }
        // Loop fortsÃ¦tter - LLM ser resultaterne
    }

    return "Max iterations reached";
}

Console.WriteLine("âœ… RunAgent function defined (~50 lines)");

#!markdown

## 1.6 Test din Agent!

#!csharp

var result = await RunAgent(
    "Hvilke ladestationer er ledige lige nu?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result);

#!csharp

var result2 = await RunAgent(
    "Hvad er status pÃ¥ CPH-002?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result2);

#!csharp

var result3 = await RunAgent(
    "Hvad koster det at lade 50 kWh kl. 18? Og hvad hvis jeg venter til kl. 22?",
    tools
);

Console.WriteLine("\n=== Final Response ===");
Console.WriteLine(result3);

#!markdown

## Checkpoint Del 1

Du har nu:
1. âœ… Set prÃ¦cis hvad LLM'en modtager (JSON tool definitions)
2. âœ… Set prÃ¦cis hvad LLM'en returnerer (JSON tool calls)
3. âœ… Bygget `SimpleTool` - en transparent tool abstraction
4. âœ… Bygget det komplette agentic loop (~50 linjer!)
5. âœ… KÃ¸rt en agent med 3 ChargeSmart tools

**NÃ¸gleindsigt:** Det er sÃ¥ simpelt. ~50 linjer loop + ~10 linjer per tool. *The emperor has no clothes!*

---

#!markdown

# Del 2: Abstraktionsstigen â€“ OllamaSharp.Tool
*20 minutter*

Nu hvor du forstÃ¥r hvad der sker "under the hood", lad os se hvordan OllamaSharp pakker det samme.

#!markdown

## 2.1 Side-by-Side: SimpleTool vs OllamaSharp.Tool

#!csharp

// DIN SimpleTool - alt er synligt:
var simpleToolExample = new SimpleTool(
    Name: "get_station_status",
    Description: "Get EV charging station status",
    ParameterSchema: """{"type":"object","properties":{"stationId":{"type":"string"}},"required":["stationId"]}""",
    Execute: args => $"Station {args.GetProperty("stationId").GetString()} is available"  // <-- Koden er HER
);

// OllamaSharp's Tool - samme data, anden struktur:
var ollamaToolExample = new Tool
{
    Type = "function",
    Function = new Function
    {
        Name = "get_station_status",
        Description = "Get EV charging station status",
        Parameters = new Parameters
        {
            Type = "object",
            Properties = new Dictionary<string, Property>
            {
                ["stationId"] = new Property { Type = "string", Description = "Station ID" }
            },
            Required = new[] { "stationId" }
        }
    }
};
// BEMÃ†RK: Ingen Execute property! Du skal hÃ¥ndtere eksekveringen separat i dit loop.

Console.WriteLine("SimpleTool har:");
Console.WriteLine("  - Name, Description, ParameterSchema");
Console.WriteLine("  - Execute: Func<JsonElement, string> â† KODEN ER HER");
Console.WriteLine();
Console.WriteLine("OllamaSharp.Tool har:");
Console.WriteLine("  - Type, Function (Name, Description, Parameters)");
Console.WriteLine("  - Ingen Execute! â† Du skal selv matche tool calls til kode");

#!markdown

## 2.2 NÃ¸gleindsigt

**OllamaSharp's Tool er bare en data-struktur til JSON serialisering.**

Det er derfor vi byggede `SimpleTool` fÃ¸rst - for at se det fulde billede:
1. Tool *definition* (JSON schema) â†’ sendes til LLM
2. Tool *execution* (din kode) â†’ kÃ¸rer lokalt nÃ¥r LLM requester det

Libraries som OllamaSharp giver dig #1, men du skal selv hÃ¥ndtere #2.
Vores `SimpleTool` pakker begge dele sammen sÃ¥ det er tydeligt.

#!markdown

## 2.3 Ã˜velse: Refaktorer til OllamaSharp.Tool

Konverter Ã©n af dine SimpleTool definitioner til OllamaSharp.Tool format.
Behold samme execution logic i dit loop.

<details>
<summary>Hint: Se lÃ¸sningen</summary>

```csharp
// SimpleTool version:
var getStatus = new SimpleTool(
    Name: "get_station_status",
    // ...
    Execute: args => { /* kode */ }
);

// OllamaSharp version:
var getStatusTool = new Tool {
    Function = new Function {
        Name = "get_station_status",
        // ... (ingen Execute!)
    }
};

// Execution hÃ¥ndteres separat i loop:
if (toolCall.Function.Name == "get_station_status")
{
    result = /* din execution kode */;
}
```

</details>

#!markdown

---

# â˜• PAUSE (15 min)

---

#!markdown

# Del 3: Abstraktionsstigen â€“ MCP
*50 minutter*

Vi fortsÃ¦tter op ad abstraktionsstigen: SimpleTool â†’ OllamaSharp.Tool â†’ **MCP**.

## Teori: Model Context Protocol (MCP)

### Problemet: NÃ—M Integrationer

<img src="images/mcp-problem.svg" alt="MCP Problem" width="600" style="max-width: 100%;">

Uden standardisering: Hver agent skal have custom integration til hver tool.

### LÃ¸sningen: MCP som Standard

<img src="images/mcp-solution.svg" alt="MCP Solution" width="600" style="max-width: 100%;">

**MCP = USB-C for AI tools.** *Plug any tool into any agent.*

#!markdown

## 3.1 Hvad Ã†ndrer Sig med MCP?

**FÃ¸r (Del 1-2):** Tools defineret inline i din kode
```csharp
var tools = new Dictionary<string, SimpleTool> {
    ["get_station_status"] = new SimpleTool(..., Execute: args => ...)
};
// Tools lever i din agent kode
```

**Efter (Del 3):** Tools kommer fra eksterne MCP servere
```csharp
var mcpClient = await McpClient.CreateAsync(transport);
var tools = await mcpClient.ListToolsAsync();
// Tools opdages dynamisk fra server!
```

**Samme agent loop, men tools er *"pluggable"*.**

#!markdown

## 3.2 MCP Protocol Basics

MCP bruger **JSON-RPC 2.0** over stdio (lokalt) eller SSE (remote).

Tre hovedoperationer:
1. `initialize` - Handshake mellem client og server
2. `tools/list` - Hent liste af tilgÃ¦ngelige tools
3. `tools/call` - Kald et specifikt tool

#!csharp

// Microsoft.Extensions.AI for AIFunctionFactory
#r "nuget: Microsoft.Extensions.AI, 9.5.0"

using Microsoft.Extensions.AI;

Console.WriteLine("âœ… Microsoft.Extensions.AI indlÃ¦st!");

#!markdown

## 3.3 AIFunction Tools med Microsoft.Extensions.AI

MCP er designet til **inter-proces** kommunikation (client og server i separate processer).
I en notebook bruger vi i stedet `AIFunctionFactory` fra Microsoft.Extensions.AI, som giver samme tool-oplevelse **in-process**.

> **Note:** I produktion ville du forbinde til en ekstern MCP server via `StdioClientTransport` eller `HttpClientTransport`.

#!csharp

// Opret AIFunction tools fra vores ChargeSmart metoder
var aiTools = new List<AITool>
{
    AIFunctionFactory.Create(
        (string stationId) =>
        {
            if (!stations.TryGetValue(stationId, out var station))
                return $"Error: Station {stationId} not found";

            var hasSession = activeSessions.TryGetValue(stationId, out var session);
            return hasSession
                ? $"Station {stationId} ({station.Name}): IN USE by {session.vehicleId} since {session.start:HH:mm}, {session.kwh:F1} kWh delivered. {station.PowerKw}kW {station.Type} charger."
                : $"Station {stationId} ({station.Name}): AVAILABLE. {station.PowerKw}kW {station.Type} charger at {station.Location}.";
        },
        "get_station_status",
        "Get real-time status of an EV charging station. Parameter: stationId (e.g. CPH-001)"),

    AIFunctionFactory.Create(
        () =>
        {
            var lines = stations.Values.Select(s =>
            {
                var status = activeSessions.ContainsKey(s.Id) ? "IN USE" : "AVAILABLE";
                return $"- {s.Id}: {s.Name} ({s.Location}) - {s.PowerKw}kW {s.Type} - {status}";
            });
            return "ChargeSmart Network Stations:\n" + string.Join("\n", lines);
        },
        "list_stations",
        "List all EV charging stations in the ChargeSmart network with their current availability"),

    AIFunctionFactory.Create(
        (double kwh, int hour) =>
        {
            var tariff = GetTariff(hour);
            var cost = (decimal)kwh * tariff;
            var period = hour switch
            {
                >= 0 and < 6 => "off-peak",
                >= 17 and < 21 => "peak",
                _ => "normal"
            };
            return $"Charging {kwh:F1} kWh at {hour:00}:00 ({period} tariff: {tariff:F2} DKK/kWh) = {cost:F2} DKK";
        },
        "calculate_charging_cost",
        "Calculate the cost of charging based on kWh needed and hour of day (0-23)")
};

Console.WriteLine($"ğŸ”Œ Oprettet {aiTools.Count} AIFunction tools:");
foreach (var tool in aiTools)
{
    Console.WriteLine($"   - {tool.Name}: {tool.Description}");
}

#!markdown

## 3.4 IChatClient + UseFunctionInvocation()

Her kommer magien - eller rettere, **automationen af det loop du byggede i Del 1!**

OllamaSharp implementerer `IChatClient` fra Microsoft.Extensions.AI.
`UseFunctionInvocation()` automatiserer hele loop'et.

#!csharp

// OllamaApiClient IS an IChatClient!
var ollama = new OllamaApiClient("http://localhost:11434");
ollama.SelectedModel = selectedModelName ?? "llama3.1:8b";

// Wrap med automatisk function invocation
// Dette ER det agentic loop fra Del 1 - bare automatiseret!
IChatClient chatClient = new ChatClientBuilder(ollama)
    .UseFunctionInvocation()  // â† Automatiserer HELE loop'et fra Del 1
    .Build();

Console.WriteLine("âœ… IChatClient med UseFunctionInvocation() klar!");
Console.WriteLine("   - Modtager tool_calls fra LLM");
Console.WriteLine("   - Eksekverer tools automatisk");
Console.WriteLine("   - Sender resultater tilbage");
Console.WriteLine("   - Looper indtil fÃ¦rdig");

#!markdown

## 3.5 Ã˜velse: ChargeSmart med AIFunction Tools

KÃ¸r samme query som i Del 1, men nu med AIFunction tools og automatiseret loop!

**BemÃ¦rk:** Samme tools, samme data - men nu via `IChatClient.UseFunctionInvocation()`.

#!csharp

Console.WriteLine("Sender besked med AIFunction tools...\n");

var messages = new List<ChatMessage>
{
    new(Microsoft.Extensions.AI.ChatRole.User, "Hvilke ladestationer er ledige lige nu? Og hvad koster det at lade 30 kWh kl. 18?")
};

// AIFunction tools + automatisk loop via IChatClient
await foreach (var update in chatClient.GetStreamingResponseAsync(
    messages,
    new() { Tools = [.. aiTools] }))
{
    Console.Write(update.Text);
}

Console.WriteLine("\n\nâœ… Done!")

#!markdown

## Checkpoint Del 3

Du har nu:
1. âœ… ForstÃ¥et MCP som "USB-C for AI tools"
2. âœ… Oprettet tools med `AIFunctionFactory` fra Microsoft.Extensions.AI
3. âœ… Set hvordan `IChatClient.UseFunctionInvocation()` automatiserer loop'et
4. âœ… KÃ¸rt en agent med automatiseret tool invocation

**NÃ¸gleindsigt:** MCP standardiserer tool connectivity. I produktion forbinder du til eksterne MCP servere - i notebooks bruger vi `AIFunctionFactory` som in-process alternativ.

---

#!markdown

# Del 4: Skills â€“ teori og prÃ¸v med GitHub Copilot
*40 minutter*

## SEPARAT VEJ

> **Vigtigt:** Dette er en SEPARAT tilgang fra Del 1-3.
> - Del 1-3: Byg din egen agent med Ollama
> - Del 4: Udvid GitHub Copilot med domÃ¦neviden

## Fra domÃ¦ne-specifikke agents til universel kode

**Hvordan vi plejede at tÃ¦nke:**

<img src="images/anthropic-how-we-used-to-think-about-agents.png" alt="Separate agents for each domain" width="600" style="max-width: 100%;">

Vi troede hver domÃ¦ne krÃ¦ver sin egen agent med egne tools og scaffolding.

**Hvad vi opdagede:**

<img src="images/anthropic-code-is-the-universal-interface.png" alt="Code is the universal interface" width="600" style="max-width: 100%;">

Kode er ikke bare en use case â€“ det er den universelle grÃ¦nseflade til den digitale verden.

En coding agent kan:
- Kalde API'er for at hente data (research)
- Organisere data i filsystemet (dokumenter)
- Analysere med Python (finans)
- Generere output i ethvert format (marketing)

**Konklusion**: Vi behÃ¸ver ikke mange forskellige agents â€“ vi behÃ¸ver Ã‰N general-purpose coding agent + **skills** der giver domÃ¦neekspertise.

## Teori: Hvorfor Skills?

**Problemet:** Giv en model 100 tools, og den bliver forvirret. Tool selection degraderer.

**LÃ¸sningen:** Skills = "lazy-loaded expertise"
- En "router" klassificerer fÃ¸rst brugerens intent
- Kun relevante tools/knowledge indlÃ¦ses
- Modellen fokuserer pÃ¥ Ã©n opgave ad gangen

**Key insight:** Copilot har allerede loopet, LLM, og basale tools. Du tilfÃ¸jer domÃ¦neviden!

#!markdown

## 4.1 GitHub Copilot Agent Mode

VS Code 1.108+ har eksperimentel support for "agent skills".

### Aktivering

1. Ã…bn VS Code Settings (Ctrl+,)
2. SÃ¸g efter `chat.useAgentSkills`
3. Aktiver indstillingen

### Skill Struktur

```
.github/skills/
â””â”€â”€ ev-charging-advisor/
    â””â”€â”€ SKILL.md
```

Copilot scanner automatisk `.github/skills/` og indlÃ¦ser relevante skills.

#!markdown

## 4.2 SKILL.md Anatomi

```yaml
---
name: my-skill
description: Kort beskrivelse til discovery
triggers:
  - "nÃ¥r bruger spÃ¸rger om X"
  - "nÃ¥r der er behov for Y"
---

# Detaljerede Instruktioner

Her kommer den fulde domÃ¦neviden...
```

- **YAML frontmatter:** Metadata til skill discovery
- **Markdown body:** Instruktioner, eksempler, context

#!markdown

## 4.3 Ã˜velse: Opret EV Charging Advisor Skill

### Step 1: Opret skill mappe

**PowerShell:**
```powershell
New-Item -ItemType Directory -Force -Path ".github/skills/ev-charging-advisor"
```

**Bash:**
```bash
mkdir -p .github/skills/ev-charging-advisor
```

### Step 2: Opret SKILL.md

Opret filen `.github/skills/ev-charging-advisor/SKILL.md`:

```yaml
---
name: ev-charging-advisor
description: EkspertrÃ¥dgivning om optimering af elbil-ladning pÃ¥ ChargeSmart netvÃ¦rket
triggers:
  - "nÃ¥r bruger spÃ¸rger om ladepris"
  - "nÃ¥r bruger vil finde billigste ladetidspunkt"
  - "nÃ¥r bruger spÃ¸rger om batteri-tips"
  - "nÃ¥r bruger nÃ¦vner ChargeSmart eller elbil-ladning"
---

# EV Charging Advisor

Du er en ekspert i at optimere elbil-ladning pÃ¥ ChargeSmart netvÃ¦rket i KÃ¸benhavn.

## ChargeSmart Tarif-struktur

| Periode | Tid | Pris/kWh |
|---------|-----|----------|
| Off-peak | 00:00-06:00 | 1.50 DKK |
| Normal | 06:00-17:00, 21:00-00:00 | 2.50 DKK |
| Peak | 17:00-21:00 | 4.00 DKK |

## Stationer i NetvÃ¦rket

- CPH-001: NÃ¸rreport Station - 150kW ultra-fast
- CPH-002: Fisketorvet Parking - 50kW fast
- CPH-003: Tivoli Garage - 50kW fast
- CPH-004: Ã˜restad Center - 150kW ultra-fast
- CPH-005: Amager Strandpark - 22kW slow
- CPH-006: NÃ¸rrebro Runddel - 50kW fast
- CPH-007: Frederiksberg Have - 7kW slow
- CPH-008: Kastrup Lufthavn P4 - 150kW ultra-fast
- CPH-009: Valby Langgade - 22kW slow
- CPH-010: Hellerup Station - 50kW fast

## Instruktioner

NÃ¥r bruger spÃ¸rger om ladning:

1. **Identificer behov** - Hvor mange kWh skal de lade?
2. **Tjek tidspunkt** - HvornÃ¥r vil de lade?
3. **Beregn pris** - Brug tarif-tabellen
4. **Optimer** - ForeslÃ¥ ALTID billigere alternativer
5. **Batteri-tips** - TilfÃ¸j relevante tips

## Batteri-tips

- UndgÃ¥ at lade til 100% dagligt (80% er optimalt for battery health)
- UndgÃ¥ at kÃ¸re under 20% regelmÃ¦ssigt
- Forvarm batteri i koldt vejr fÃ¸r hurtigladning
- Ultra-fast ladning (150kW) slider mere pÃ¥ batteriet end langsom ladning

## Eksempel-dialog

**Bruger:** Hvad koster det at lade 40 kWh kl. 18?

**Svar:** At lade 40 kWh kl. 18:00 koster **160 DKK** (peak-tarif: 4.00 DKK/kWh).

ğŸ’¡ **Tip:** Hvis du kan vente til kl. 21:00, falder prisen til **100 DKK** (normal-tarif).
Eller endnu bedre - lad natten over (kl. 00-06) for kun **60 DKK**!

ğŸ”‹ **Batteri-tip:** Hvis du ikke behÃ¸ver fuld opladning, sÃ¥ lad kun til 80% for at forlÃ¦nge batteriets levetid.
```

#!markdown

### Step 3: Test med Copilot Chat

1. Ã…bn **Copilot Chat** i VS Code (Ctrl+Alt+I)
2. PrÃ¸v disse prompts:
   - "Hvad koster det at lade 50 kWh kl. 18?"
   - "Find den billigste tid at lade min elbil"
   - "Giv mig tips til at forlÃ¦nge mit EV batteri"

Copilot burde nu bruge din skill til at give ChargeSmart-specifikke svar! (Det er tilfÃ¦lded hvis du ser beskeden "Read SKILL.md file".)

#!markdown

## Checkpoint Del 4

Du har nu:
1. âœ… ForstÃ¥et Skills som "lazy-loaded expertise"
2. âœ… Oprettet en SKILL.md med domÃ¦neviden
3. âœ… Udvidet GitHub Copilot med ChargeSmart ekspertise

**NÃ¸gleindsigt:** Du behÃ¸ver ikke bygge en agent - du kan udvide Ã©n du allerede har!

---

#!markdown

# Afrunding
*10 minutter*

## To Separate Veje - Recap

### Vej A: Byg Din Egen Agent (Del 1-3)

```
SimpleTool â†’ OllamaSharp.Tool â†’ MCP Server
```

- Samme funktionalitet, stigende abstraktion
- Fuld kontrol, fuld forstÃ¥else
- **Brug nÃ¥r:** Custom agents, embedded systems, specifikke workflows

### Vej B: Udvid en Eksisterende Agent (Del 4)

```
GitHub Copilot + SKILL.md â†’ DomÃ¦neviden
```

- Byg ikke infrastruktur - tilfÃ¸j viden
- **Brug nÃ¥r:** Produktivitet, team workflows, quick wins

## Key Takeaways

1. **Agents er simple** - ~200 linjer loop kode
2. **"Magien" er i LLM'en** - ikke infrastrukturen
3. **MCP standardiserer** - USB-C for AI tools
4. **Skills tilfÃ¸jer viden** - uden at genopbygge

## NÃ¦ste Skridt: Enterprise Agent SDK'er

Nu hvor du har bygget din egen agent-loop og forstÃ¥r abstraktionerne, kan du udforske etablerede SDK'er. Disse giver dig **observability**, **multi-agent orchestration** og **enterprise compliance** ud af boksen â€“ men bygger pÃ¥ prÃ¦cis de samme principper, du har lÃ¦rt i dag.

**To tilgange dominerer:**

| | **Anthropic Claude Agent SDK** | **Microsoft Agent Framework** |
|---|---|---|
| **Filosofi** | "Giv Claude en computer" | "Unified multi-agent orchestration" |
| **Kerne** | Bash/fil-tools, subagents, MCP | AutoGen + Semantic Kernel |
| **Sprog** | Python | Python, C#, Java |
| **Styrke** | Simpel agent â†’ computer-interaktion | Enterprise: observability, compliance, A2A |
| **MCP** | âœ… Native integration | âœ… Native integration |

![Agent SDK Landscape](images/agent-sdk-landscape.svg)

> **NÃ¸gleindsigt:** Begge SDK'er bygger pÃ¥ de samme principper, du har lÃ¦rt (tools, loops, MCP). Forskellen ligger i *hvor meget* infrastruktur du fÃ¥r "gratis" â€“ og *hvilken leverandÃ¸r* du binder dig til.

## The Emperor Has No Clothes

> **"The core of these tools isn't magic. It's about 200 lines of straightforward Python."**
> â€” Mihail Eric

Du har nu set det selv. Du kan bygge en agent. Du forstÃ¥r hvad der sker.

## Ressourcer

- [MCP Documentation](https://modelcontextprotocol.io)
- [Microsoft.Extensions.AI](https://github.com/dotnet/extensions)
- [GitHub Copilot Skills](https://docs.github.com/en/copilot)
- [The Emperor Has No Clothes](https://www.mihaileric.com/The-Emperor-Has-No-Clothes/)
- [OllamaSharp](https://github.com/awaescher/OllamaSharp)
- [Building agents with the Claude Agent SDK](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk)
- [Introducing Microsoft Agent Framework](https://azure.microsoft.com/en-us/blog/introducing-microsoft-agent-framework/)

---

## Tak for i dag! ğŸ‰
